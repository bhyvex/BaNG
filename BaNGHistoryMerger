#!/usr/bin/env perl
use strict;
use warnings;
use Cwd qw( abs_path );
use File::Basename;
use Getopt::Long qw( :config no_auto_abbrev );
use Time::HiRes qw( gettimeofday );
use POSIX qw( strftime );

use lib dirname( abs_path($0) ) . '/lib';
use BaNG::Config;
use BaNG::Common;
use BaNG::Wipe;

my $version = '1.0';
my $verbose_arg;
my $dryrun_arg;
my $daylimit_arg;
my $group_arg;
my $host_arg;
my $old_bkpprefix_arg;
my $prefix_arg;
my @migrate_folders_history;
my $btrfs_snapshot_cmd;

#################################
# Main
#
parse_command_options();
get_serverconfig($prefix_arg);
cli_args_override_global_config();

my $btrfs_cmd = $serverconfig{path_btrfs};
my $taskid    = create_timeid( $host_arg, $group_arg );

get_host_config( $host_arg, $group_arg );

my $host              = $host_arg;
my $group             = $group_arg;
my $daylimit          = $daylimit_arg || "3";
my $config            = "$host-$group";
my $hostconfig        = $hosts{$config}->{hostconfig};
my $current_bkpprefix = $hostconfig->{BKP_PREFIX};
my $old_bkpprefix     = $old_bkpprefix_arg;


if ( $serverconfig{verbose} ) {
    print "\tHost: $hosts{$config}->{hostname}\n";
    print "\tGroup: $hosts{$config}->{group}\n";
    print "\tBKP-PREFIX current: $current_bkpprefix\n";
    print "\tBKP-PREFIX old: $old_bkpprefix\n";
}

# fill up @migrate_folders_history -> all folders to migrate, excl. 'to wiped' folders
eval_history_folders( $taskid, $hosts{$config}->{hostname}, $hosts{$config}->{group} );

if ( !@migrate_folders_history ) {
    print "Exit because queue is empty.\n" if $serverconfig{verbose};
    exit 1;
}

# Limit migration folders to the last x days (begin with the newest)
@migrate_folders_history = reverse sort @migrate_folders_history;
@migrate_folders_history = splice( @migrate_folders_history, 0, $daylimit );

logit( $taskid, $host, $group, "START MIGRATION for host $host group $group, migrate $daylimit days" );
$hostconfig->{BKP_PREFIX}  = $current_bkpprefix;
my $btrfs_snapshot_source  = targetpath( $host, $group ) . "/migrate";
my $btrfs_snapshot_current = targetpath( $host, $group ) . "/current";

if ( ! -e $btrfs_snapshot_source ) {
    $btrfs_snapshot_cmd = "$btrfs_cmd subvolume snapshot $btrfs_snapshot_current $btrfs_snapshot_source >/dev/null 2>&1";
    logit( $taskid, $host, $group, "Create migration snapshot folder using:\n\t$btrfs_snapshot_cmd" );
    $btrfs_snapshot_cmd = "echo $btrfs_snapshot_cmd" if $serverconfig{dryrun};
    system($btrfs_snapshot_cmd) and  print "ERROR: creating snapshot for $host-$group: $!\n";
}

foreach my $folder ( reverse sort @migrate_folders_history ) {
    logit( $taskid, $host, $group, "Work on: $folder" );
    my ($workfolder) = $folder =~ /\/([\d._]*)$/;

    my $rsync_cmd     = $serverconfig{path_rsync};
    my $rsync_options = "--stats -a -H --delete --delete-excluded --acls -e rsh ";

    $hostconfig->{BKP_PREFIX} = $old_bkpprefix;
    my $rsync_src  = targetpath( $host, $group ) . "/$workfolder/";
    $hostconfig->{BKP_PREFIX} = $current_bkpprefix;
    my $rsync_dest  = targetpath( $host, $group ) . "/migrate";

    if ( $hostconfig->{BKP_EXCLUDE_FILE} ) {
        my $excludefile = "$serverconfig{path_excludes}/$hostconfig->{BKP_EXCLUDE_FILE}";
        if ( -e $excludefile ) {
            $rsync_options .= "--exclude-from=$serverconfig{path_excludes}/$hostconfig->{BKP_EXCLUDE_FILE} ";
        } else {
            print "Warning: could not find excludefile $excludefile.\n";
        }
    }

    logit( $taskid, $host, $group, "RSYNC:\n\t$rsync_cmd $rsync_options $rsync_src $rsync_dest" );
    system("$rsync_cmd $rsync_options $rsync_src $rsync_dest") unless $serverconfig{dryrun};

    ### do Snapshot Work
    my $btrfs_snapshot_dest = targetpath( $host, $group ) . "/$workfolder";

    $btrfs_snapshot_cmd = "$btrfs_cmd subvolume snapshot -r $btrfs_snapshot_source $btrfs_snapshot_dest >/dev/null 2>&1";
    $btrfs_snapshot_cmd = "echo $btrfs_snapshot_cmd" if $serverconfig{dryrun};
    logit( $taskid, $host, $group, "Create btrfs snapshot $folder using\n\t$btrfs_snapshot_cmd" );
    system($btrfs_snapshot_cmd) and  print "ERROR: creating snapshot for $host-$group: $!\n";
    logit( $taskid, $host, $group, "FINISHED migration of $folder" );
}

exit 0;

#################################
# Sub-Functions
#
sub eval_history_folders {
    my ( $taskid, $host, $group ) = @_;

    logit( $taskid, $host, $group, "Queueing folders for host $host group $group" );

    my @backup_folders;
    my $count = 0;
    my $oldestCurFolder;

    foreach my $bkpprefix ( $current_bkpprefix, $old_bkpprefix ) {
        $hostconfig->{BKP_PREFIX} = $bkpprefix;
        logit( $taskid, $host, $group, "Check available folders for BKP-PREFIX: $bkpprefix" );
        foreach my $folder ( get_backup_folders( $host, $group ) ) {
            if ( $count == 0 ) {
                $oldestCurFolder = $folder;
                chomp $oldestCurFolder;
            }
            $count++;
            print "\tCollect folder for $bkpprefix: $folder" if $serverconfig{verbose};
            push( @backup_folders, $folder );
        }
    }
    logit( $taskid, $host, $group, "OldestCurrentFolder: $oldestCurFolder" );

    # count existing backups
    my $bkpkeep = 0;
    foreach my $type (qw( DAILY WEEKLY MONTHLY )) {
        $bkpkeep += $hostconfig->{"WIPE_KEEP_$type"};
    }
    my $bkpcount = $#backup_folders + 1;

    # get list of folders to wipe
    my %stack = list_folders_to_wipe( $host, $group, @backup_folders );

    logit( $taskid, $host, $group, "Backups existing: $bkpcount, to wipe: " . ( $#{$stack{wipe}} + 1 ) . ", keeping: $bkpkeep for host $host group $group" );

    # generate wipe report with content of stacks
    if ( $serverconfig{verboselevel} >= 2 && $serverconfig{verbose} ) {
        my $wipe_report = "Wipe report\n";
        foreach my $type ( sort keys %stack ) {
            $wipe_report .= "\t" . uc($type) . " : " . ( $#{$stack{$type}} + 1 ) . "\n";
            foreach my $folder ( @{$stack{$type}} ) {
                $wipe_report .= "\t$folder\n";
            }
        }
        print $wipe_report;
    }

    foreach my $type (qw( daily weekly monthly )) {
        foreach my $folder ( @{$stack{$type}} ) {
            next if $folder =~ m/$current_bkpprefix\//;
            push( @migrate_folders_history, $folder );
        }
    }
    if ( $serverconfig{verbose} ) {
        print "Migrate following folders:\n" if $serverconfig{verbose};
        foreach my $folder ( reverse sort @migrate_folders_history ) {
            print "\t$folder\n";
        }
    }
    logit( $taskid, $host, $group, "End of queueing History Merge of host $host group $group" );

    return 1;
}

#################################
# Helper subroutines
#
sub logit {
    my ( $taskid, $host, $group, $msg ) = @_;

    my $timestamp = strftime '%b %d %H:%M:%S', localtime;
    my $logmonth  = strftime '%Y-%m',          localtime;
    my $logdate    = strftime $serverconfig{global_log_date}, localtime;
    my $logfile    = "$serverconfig{path_logs}/historymerger_$logdate.log";
    my $logmessage = "$timestamp $host-$group($taskid) : $msg";
    $logmessage .= "\n" unless ( $logmessage =~ m/\n$/ );

    if ( $serverconfig{verbose} ) {
        if ( $serverconfig{dryrun} ) {
            print $logmessage;
        }
    }

    unless ( $serverconfig{dryrun} ) {
        open my $log, ">>", $logfile or print "ERROR opening logfile $logfile: $!\n";
        print {$log} $logmessage;
        close $log;
    }

    return 1;
}

sub create_timeid {
    my ( $host, $group, $taskid ) = @_;

    my ( $s, $usec ) = gettimeofday;
    my $timeid = `$serverconfig{path_date} +'%Y%m%d%H%M%S'` . $usec;
    $timeid =~ s/\n//g;
    $host   ||= 'SERVER';
    $group  ||= 'GLOBAL';
    $taskid ||= $timeid;
    logit( $taskid, $host, $group, "Created TimeID: $timeid" );

    return $timeid;
}

#################################
# Command line arguments
#
sub parse_command_options {
    GetOptions(
        'help'            => sub { usage('') },
        'v|verbose'       => \$verbose_arg,
        'n|dry-run'       => \$dryrun_arg,
        'daylimit=s'      => \$daylimit_arg,
        'g|group=s'       => \$group_arg,
        'h|host=s'        => \$host_arg,
        'old-bkpprefix=s' => \$old_bkpprefix_arg,
    ) or usage('Invalid commmand line options.');
    usage('Check the arguments!') unless ( $host_arg && $group_arg && $old_bkpprefix_arg );

    $verbose_arg = 1 if $dryrun_arg;

    return 1;
}

sub cli_args_override_global_config {

    $serverconfig{verbose} = $verbose_arg if $verbose_arg;
    $serverconfig{dryrun}  = $dryrun_arg  if $dryrun_arg;

    return 1;
}

sub usage {
    my ($message) = @_;

    if ( defined $message && length $message ) {
        $message .= "\n"
            unless $message =~ /\n$/;
    }

    my $command = $0;
    $command =~ s#^.*/##;

    print <<"EOF";
        $message
        Usage Examples:

        $command -h <host> -g <group> --old-bkpprefix <BKP_PREFIX>

        Optional Arguments:

        --daylimit <x>    # migrate only x days, default 3
        -v                # verbose mode to include debugging messages
        -n                # dry-run without making changes (implies verbose)

EOF

    exit 0;
}
