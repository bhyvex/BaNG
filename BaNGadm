#!/usr/bin/env perl
use strict;
use warnings;
use Cwd qw( abs_path );
use File::Basename;
use Getopt::Long qw( :config no_auto_abbrev );
use POSIX qw( strftime );

use lib dirname( abs_path($0) ) . '/lib';
use BaNG::Config;
use BaNG::Common;

my $version = '0.1';
my $add_arg;
my $delete_arg;
my $crontabcreate;
my $setprop;
my $verbose_arg;
my $dryrun_arg;
my $group_arg;
my $host_arg;
my $prefix_arg;
my $showgroups;

#################################
# Main
#
parse_command_options();
get_serverconfig($prefix_arg);
cli_args_override_global_config();

if ($crontabcreate) {
    my $crontab = generated_crontab();
    if ( $serverconfig{dryrun} ) {
        print "$crontab\n";
    } else {
        print "write crontab\n";
        open CRONTAB, '>', '/etc/cron.d/BaNG'
            or die('Could not open /etc/cron.d/BaNG');
        print CRONTAB $crontab;
        close CRONTAB;
    }

    exit 0;
}

if ($showgroups) {
    get_group_config();

    print "All available Backup Groups:\n";
    print "----------------------------\n";
    foreach my $group ( sort keys %groups ) {
        print "$group \n";
    }

    exit 0;
}

if ($setprop) {
    get_host_config( $host_arg, $group_arg );
    my @backup_folders = get_backup_folders( $host_arg, $group_arg );

    if ($setprop eq "list") {
        print "Snapshot property (rw/ro) of $host_arg - $group_arg\n";
        foreach my $folder (@backup_folders) {
            chomp $folder;
            my $result = `$serverconfig{path_btrfs} property get -ts $folder`;
            chomp $result;
            if ( $result =~ /^ro=true$/ ) {
                $result = "Read-Only";
            } else {
                $result = "=> Read-Write !!!";
            }
            print "$folder $result\n";
        }
    } elsif ($setprop eq "ro") {
        print "Set snapshots property of $host_arg - $group_arg to Read-Only\n";
        foreach my $folder (@backup_folders) {
            chomp $folder;
            my $result = `$serverconfig{path_btrfs} property set -ts $folder ro true`;
            print "set $folder to Read-Only\n";
        }
    } elsif ($setprop eq "rw") {
        print "Set snapshots property of $host_arg - $group_arg to Read-Write\n";
        foreach my $folder (@backup_folders) {
            chomp $folder;
            my $result = `$serverconfig{path_btrfs} property set -ts $folder ro false`;
            print "set $folder to Read-Write\n";
        }
    }
    exit 0;
}

if ($add_arg) {
    my $timestamp = strftime( '%Y/%m/%d %H:%M:%S', localtime );
    my $createdby = 'root with CLI';
    my $configtype;

    if ( $host_arg && $group_arg ) {
        $configtype = 'host';
    } elsif ( !$host_arg && $group_arg ) {
        $host_arg   = '0';
        $configtype = 'group';
    }

    my $settings;
    $settings->{'COMMENT'} = "Created by $createdby at $timestamp";

    my ( $return_code, $return_msg ) = write_config( $configtype, 'add', $host_arg, $group_arg, $settings );

    if ( $return_code eq '1' ) {
        print "Configfile $return_msg created\n";
    } else {
        print "$return_msg\n";
    }

    exit 0;
}

if ($delete_arg) {
    my $configtype;
    my $file;

    if ( $host_arg && $group_arg ) {
        $configtype = 'host';
        $file       = $host_arg . '_' . "$group_arg.yaml";
    } elsif ( !$host_arg && $group_arg ) {
        $configtype = 'group';
        $file       = "$group_arg.yaml";
    }

    my ( $return_code, $return_msg ) = delete_config( $configtype, $file );
    print "$return_msg\n";

    exit 0;
}

#################################
# Command line arguments
#
sub parse_command_options {

    GetOptions(
        'help'           => sub { usage('') },
        'version'        => sub { usage("Current version number: $version") },
        'v|verbose'      => \$verbose_arg,
        'n|dry-run'      => \$dryrun_arg,
        'add'            => \$add_arg,
        'delete'         => \$delete_arg,
        'g|group=s'      => \$group_arg,
        'h|host=s'       => \$host_arg,
        'crontab-create' => \$crontabcreate,
        'p|prefix=s'     => \$prefix_arg,
        'showgroups'     => \$showgroups,
        'setprop=s'      => \$setprop,
    ) or usage('Invalid commmand line options.');
    usage('Do not use together!') if ( $crontabcreate && $showgroups );
    usage('Check the arguments!') unless ( ( $add_arg || $delete_arg ) && ( ( $host_arg && $group_arg ) || $group_arg ) || ( $crontabcreate || $showgroups ) || ( $host_arg && $group_arg  && $setprop ));

    $verbose_arg = 1 if $dryrun_arg;

    return 1;
}

sub cli_args_override_global_config {

    $serverconfig{verbose} = $verbose_arg if $verbose_arg;
    $serverconfig{dryrun}  = $dryrun_arg  if $dryrun_arg;

    return 1;
}

sub usage {
    my ($message) = @_;

    if ( defined $message && length $message ) {
        $message .= "\n"
            unless $message =~ /\n$/;
    }

    my $command = $0;
    $command =~ s#^.*/##;

    print <<"EOF";
        $message
        Usage Examples:

        $command --add -h <host> -g <group>           # create a new host config
        $command --add -g <group>                     # create a new group config

        $command --delete -h <host> -g <group>        # delete a existing host config
        $command --delete -g <group>                  # delete a existing group config

        $command --setprop list -h <host> -g <group>  # show Read-Write/Read-Only status of all snapshots
        $command --setprop rw|ro -h <host> -g <group> # set all snapshots to Read-Write/Read-Only

        $command --crontab-create                     # generated and write crontab
        $command --showgroups                         # show available groups
        $command --help                               # show this help message
        $command --version                            # show version number and help

        Optional Arguments:

        -v              # verbose mode to include debugging messages
        -n              # dry-run without making changes (implies verbose)

EOF

    exit 0;
}
