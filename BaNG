#!/usr/bin/env perl
#
# Copyright 2013 Patrick Schmid <schmid@phys.ethz.ch>, distributed under
# the terms of the GNU General Public License version 2 or later.
#
# Authors: Patrick Schmid <schmid@phys.ethz.ch> & Claude Becker <becker@phys.ethz.ch>
#
use strict;
use warnings;
use Cwd qw( abs_path );
use File::Basename;
use Getopt::Long qw( :config no_auto_abbrev );
use IPC::Open3;
use Mail::Sendmail;
use POSIX qw( strftime );
use Template;
use threads;
use Thread::Queue;

use lib dirname( abs_path($0) ) . "/lib";
use BaNG::Hosts;
use BaNG::Config;
use BaNG::Reporting;

my $version    = '3.0';
my $debuglevel = 2;
my $debug;
my $dryrun;
my $wipe;
my $hobbitonly;
my $group_arg;
my $host_arg;
my $prefix_arg;
my $nthreads_arg;
my @queue;
my @subfolder_hosts;

#################################
# Main
#
parse_command_options();
get_global_config($prefix_arg);
get_host_config($host_arg, $group_arg);

foreach my $config ( keys %hosts ) {
    if ( $wipe ) {
        wipe( $hosts{$config}->{hostname}, $hosts{$config}->{group} );
    } elsif ( $hobbitonly  ) {
        hobbit_report( $hosts{$config}->{hostname}, $hosts{$config}->{group} );
    } else {
        queue_backup( $hosts{$config}->{hostname}, $hosts{$config}->{group} );
    }
}

if ( !@queue ) {
    print "Exit because queue is empty.\n" if $debug;
    exit 0;
}

start_threads();
finish_backupjob($_) foreach @subfolder_hosts;

exit 0;

#################################
# Queuing
#
sub queue_backup {
    my ($host, $group) = @_;

    logit( $host, $group, "Queueing backup for host $host group $group" );

    # make sure backup is enabled
    return unless $hosts{"$host-$group"}->{status} eq 'enabled';

    # stop if trying to do bulk backup if it's not allowed
    return unless ( ($group_arg && $host_arg) || $hosts{"$host-$group"}->{hostconfig}->{BKP_BULK_ALLOW} );

    # make sure host is online
    my ($conn_status, $conn_msg) = chkClientConn( $host, $hosts{"$host-$group"}->{hostconfig}->{BKP_GWHOST} );
    logit( $host, $group, "chkClientConn: $conn_status, $conn_msg" );
    if ( !$conn_status ) {
        logit( $host, $group, "Error: host $host is offline" );
        return 1;
    }

    # check if last backup exists
    my $lastbkp = chkLastBkp($host, $group);
    my $bkptimestamp  = eval_bkptimestamp($host, $group);

    # get list of partitions to back up
    my (@src_part) = split( / /, $hosts{"$host-$group"}->{hostconfig}->{BKP_SOURCE_PARTITION} );
    logit( $host, $group, "Number of partitions: " . ($#src_part+1) . " ( @src_part )" );

    # optionally queue each subfolder of the partitions
    if ( $hosts{"$host-$group"}->{hostconfig}->{BKP_THREAD_SUBFOLDERS} ) {
        foreach my $part (@src_part) {
            queue_remote_subfolders( $host, $group, $lastbkp, $bkptimestamp, $part );
        }

        my $bkpjob = {
            host         => $host,
            group        => $group,
            bkptimestamp => $bkptimestamp,
        };
        push( @subfolder_hosts, $bkpjob );

    } else {
        # queue list of partitions as a whole
        my $bkpjob = {
            host         => $host,
            group        => $group,
            path         => "@src_part",
            lastbkp      => $lastbkp,
            bkptimestamp => $bkptimestamp,
        };
        push( @queue, $bkpjob );
    }

    logit( $host, $group, "End of queueing backup of host $host group $group" );

    return 1;
}

sub queue_remote_subfolders {
    my ($host, $group, $lastbkp, $bkptimestamp, $partition) = @_;
    $partition =~ s/://;

    my $remoteshell   = $hosts{"$host-$group"}->{hostconfig}->{BKP_RSYNC_RSHELL};
    my @remotedirlist = `$remoteshell $host find $partition -xdev -mindepth 1 -maxdepth 1`;
    logit( $host, $group, "eval subfolders command:\n @remotedirlist" );

    foreach my $remotedir (@remotedirlist) {
        chomp $remotedir;
        $remotedir =~ s| |\\ |g;

        my $bkpjob = {
            host         => $host,
            group        => $group,
            path         => ":'${remotedir}'",
            lastbkp      => $lastbkp,
            bkptimestamp => $bkptimestamp,
        };
        push( @queue, $bkpjob );
    }

    return 1;
}

#################################
# Threading
#
sub start_threads {

    # define number of threads
    my $nthreads;
    if ( $nthreads_arg ) {
        # If nthreads was defined by cli argument, use it
        $nthreads = $nthreads_arg;
        print "Using nthreads = $nthreads from command line argument\n" if $debug;
    } elsif ( $host_arg && $group_arg ) {
        # If no nthreads was given, and we back up a single host and group, get nthreads from its config
        $nthreads = $hosts{"$host_arg-$group_arg"}->{hostconfig}->{BKP_THREADS_DEFAULT};
        print "Using nthreads = $nthreads from $host_arg-$group_arg config file\n" if $debug;
    } else {
        $nthreads = 1;
    }

    my $Q = Thread::Queue->new;
    my @threads = map { threads->create( \&thread_work, $Q ) } (1 .. $nthreads);
    $Q->enqueue($_) for @queue;
    $Q->enqueue( (undef) x $nthreads );
    $_->join for @threads;

    return 1;
}

sub thread_work {
    my ($Q) = @_;

    while ( my $bkpjob = $Q->dequeue ) {
        my $tid          = threads->tid;
        my $host         = $bkpjob->{host};
        my $group        = $bkpjob->{group};
        my $path         = $bkpjob->{path};
        my $lastbkp      = $bkpjob->{lastbkp};
        my $bkptimestamp = $bkpjob->{bkptimestamp};

        return unless createLockFile( $host, $group, $path );
        logit( $host, $group, "Thread $tid working on $host-$group ($path)" );
        execute_rsync( $host, $group, $lastbkp, $bkptimestamp, $path );
        unless( $hosts{"$host-$group"}->{hostconfig}->{BKP_THREAD_SUBFOLDERS} ) {
            my $bkpjob = {
                host         => $host,
                group        => $group,
                bkptimestamp => $bkptimestamp,
            };
            finish_backupjob($bkpjob);
        }
        removeLockFile( $host, $group, $path );
    }

    return 1;
}

#################################
# Rsync
#
sub eval_rsync_options {
    my ($host, $group, $lastbkp) = @_;
    my $rsync_options = '';
    my $hostconfig    = $hosts{"$host-$group"}->{hostconfig};

    $rsync_options .= "--stats ";
    $rsync_options .= "-ax "            if $hostconfig->{BKP_RSYNC_ARCHIV};
    $rsync_options .= "-R "             if $hostconfig->{BKP_RSYNC_RELATIV};
    $rsync_options .= "-H "             if $hostconfig->{BKP_RSYNC_HLINKS};
    $rsync_options .= "--delete "       if $hostconfig->{BKP_RSYNC_DELETE};
    $rsync_options .= "--force "        if $hostconfig->{BKP_RSYNC_DELETE_FORCE};
    $rsync_options .= "--numeric-ids "  if $hostconfig->{BKP_RSYNC_NUM_IDS};
    $rsync_options .= "--inplace "      if $hostconfig->{BKP_RSYNC_INPLACE};
    $rsync_options .= "--acls "         if $hostconfig->{BKP_RSYNC_ACL};
    $rsync_options .= "--xattrs "       if $hostconfig->{BKP_RSYNC_XATTRS};
    $rsync_options .= "--no-D "         if $hostconfig->{BKP_RSYNC_OSX};
    $rsync_options .= "-v "             if ($debug && ($debuglevel == 3));
    $rsync_options .= "--rsync-path=$hostconfig->{BKP_RSYNC_RSHELL_PATH} " if $hostconfig->{BKP_RSYNC_RSHELL_PATH};

    if ( $hostconfig->{BKP_EXCLUDE_FILE} ) {
        my $excludefile = "$globalconfig{path_excludes}/$hostconfig->{BKP_EXCLUDE_FILE}";
        if ( -e $excludefile ) {
            $rsync_options .= "--exclude-from=$globalconfig{path_excludes}/$hostconfig->{BKP_EXCLUDE_FILE} ";
        } else {
            logit( $host, $group, "Warning: could not find excludefile $excludefile." );
        }
    }

    if ( $hostconfig->{BKP_RSYNC_RSHELL} ) {
        if ( $hostconfig->{BKP_GWHOST} ) {
            $rsync_options .= "-e $hostconfig->{BKP_RSYNC_RSHELL} $hostconfig->{BKP_GWHOST} ";
        } else {
            $rsync_options .= "-e $hostconfig->{BKP_RSYNC_RSHELL} ";
        }
    }

    # use links if told to and if lastbkp exists
    if ( ($hostconfig->{BKP_STORE_MODUS} eq 'links') && ($lastbkp ne 'nolastbkp') ) {
        $rsync_options .= "--link-dest " . targetpath($host, $group) . "/$lastbkp ";
    }

    $rsync_options =~ s/\s+$//; # remove trailing space

    return $rsync_options;
}

sub eval_rsync_target {
    my ($host, $group, $bkptimestamp) = @_;

    my $rsync_target = targetpath($host, $group);

    if ( !-d $rsync_target ) {
        system("mkdir -p $rsync_target") unless $dryrun;
    }

    if ( $hosts{"$host-$group"}->{hostconfig}->{BKP_STORE_MODUS} eq 'snapshots' ) {
        $rsync_target .= "/current";

        if ( !-d $rsync_target ) {
            create_btrfs_subvolume( $host, $group, $rsync_target );
        }
    } else {
        $rsync_target .= "/$bkptimestamp";
    }

    return $rsync_target;
}

sub execute_rsync {
    my ($host, $group, $lastbkp, $bkptimestamp, $path) = @_;

    $bkptimestamp  = eval_bkptimestamp($host, $group) unless $bkptimestamp;
    my $startstamp = `date +%s`;

    my $rsync_cmd     = $globalconfig{path_rsync};
    my $rsync_options = eval_rsync_options($host,$group, $lastbkp);
    my $rsync_source  = "$host$path";
    my $rsync_target  = eval_rsync_target($host, $group, $bkptimestamp);

    logit( $host, $group, "Rsync Command: $rsync_cmd $rsync_options $rsync_source $rsync_target" );
    logit( $host, $group, "Executing rsync for host $host group $group path $path" );

    local(*HIS_IN, *HIS_OUT, *HIS_ERR);
    $rsync_cmd = "echo $rsync_cmd" if $dryrun;
    my $rsyncpid = open3( *HIS_IN, *HIS_OUT, *HIS_ERR, "$rsync_cmd $rsync_options $rsync_source $rsync_target" );
    my @outlines = <HIS_OUT>;
    my @errlines = <HIS_ERR>;
    close HIS_IN;
    close HIS_OUT;
    close HIS_ERR;

    logit( $host, $group, "Rsync STDOUT: @outlines" ) if ( @outlines && $debuglevel >=2 );
    logit( $host, $group, "ERROR: Rsync STDERR: @errlines" ) if @errlines;
    logit( $host, $group, "ERROR: Rsync child exited with status of $?" ) if $?;

    my $errcode = 0;
    my $endstamp = `date +%s`;

    if ( @errlines ){
        foreach my $errline (@errlines) {
            if ( $errline =~ /.* \(code (\d+)/ ) {
                $errcode = $1;
                logit( $host, $group, "Rsync errorcode: $errcode" );
            }
        }
    } else {
        logit( $host, $group, "Rsync successful for host $host group $group path $path" );
    }

    db_report($host, $group, $startstamp, $endstamp, $path, targetpath($host, $group), $bkptimestamp, $errcode, @outlines);

    return 1;
}

#################################
# Btrfs
#
sub create_btrfs_subvolume {
    my ( $host, $group, $path ) = @_;

    my $btrfs_subvolume_cmd = "$globalconfig{path_btrfs} subvolume create $path";
    $btrfs_subvolume_cmd    = "echo $btrfs_subvolume_cmd" if $dryrun;

    logit( $host, $group, "Create btrfs subvolume: $btrfs_subvolume_cmd" );
    system($btrfs_subvolume_cmd) and logit( $host, $group, "ERROR: creating subvolume for $host-$group: $!" );

    return 1;
}

sub create_btrfs_snapshot {
    my ( $host, $group, $bkptimestamp ) = @_;

    return unless ( $hosts{"$host-$group"}->{hostconfig}->{BKP_STORE_MODUS} eq 'snapshots' );

    my $btrfs_cmd             = $globalconfig{path_btrfs};
    my $btrfs_snapshot_source = targetpath( $host, $group ) . "/current";
    my $btrfs_snapshot_dest   = targetpath( $host, $group ) . "/" . $bkptimestamp;

    my $touch_current_cmd    = "touch $btrfs_snapshot_source >/dev/null 2>&1";
    $touch_current_cmd       = "echo $touch_current_cmd" if $dryrun;
    logit( $host, $group, "Touch current folder for host $host group $group" );
    system($touch_current_cmd) and logit( $host, $group, "ERROR: touching current folder for $host-$group: $!" );

    my $btrfs_snapshot_cmd    = "$btrfs_cmd subvolume snapshot -r $btrfs_snapshot_source $btrfs_snapshot_dest >/dev/null 2>&1";
    $btrfs_snapshot_cmd       = "echo $btrfs_snapshot_cmd" if $dryrun;
    logit( $host, $group, "Create btrfs snapshot for host $host group $group using $btrfs_snapshot_cmd" );
    system($btrfs_snapshot_cmd) and logit( $host, $group, "ERROR: creating snapshot for $host-$group: $!" );

    return 1;
}

#################################
# Wipe old backups
#
sub wipe {
    my ($host, $group) = @_;

    logit( $host, $group, "Wipe host $host group $group" );
    # execute_wipe unless $dryrun;

    return 1;
}

#################################
# Lockfile
#
sub LockFile {
    my ($host, $group, $path) = @_;

    $path =~ s/^://g;
    $path =~ s/\s:/\+/g;
    $path =~ s/\//%/g;
    my $lockfilename = "${host}_${group}_${path}";
    my $lockfile     = "$globalconfig{path_lockfiles}/$lockfilename";

    return $lockfile;
}

sub createLockFile {
    my ($host, $group, $path) = @_;

    my $lockfile = LockFile($host, $group, $path);

    if ( -e $lockfile ) {
        logit( $host, $group, "ERROR: lockfile $lockfile still exists" );
        return 0;
    } else {
        unless ($dryrun) {
            system("touch \"$lockfile\"") and logit( $host, $group, "ERROR: could not create lockfile $lockfile" );
        }
        logit( $host, $group, "Created lockfile $lockfile." );
        return 1;
    }
}

sub removeLockFile {
    my ($host, $group, $path) = @_;

    my $lockfile = LockFile($host, $group, $path);
    unlink $lockfile unless $dryrun;
    logit( $host, $group, "Removed lockfile $lockfile." );

    return 1;
}

#################################
# LastBkpFile
#
sub LastBkpFile {
    my ($host, $group) = @_;

    my $hostconfig  = $hosts{"$host-$group"}->{hostconfig};
    my $bkpdir      = "$hostconfig->{BKP_TARGET_PATH}/$hostconfig->{BKP_PREFIX}/$host";
    my $lastBkpFile = "$bkpdir/$hostconfig->{BKP_LASTBKP_FILE}";

    return $lastBkpFile;
}

sub chkLastBkp {
    my ($host, $group) = @_;

    my $lastbkp = 'nolastbkp';
    my $lastBkpFile = LastBkpFile($host, $group);

    if ( -e $lastBkpFile ) {
        $lastbkp = `cat $lastBkpFile`;
        chomp($lastbkp);
    }

    logit( $host, $group, "Found lastbkp = $lastbkp" );

    return $lastbkp;
}

sub createLastBkpFile {
    my ($host, $group, $bkptimestamp) = @_;

    my $lastBkpFile = LastBkpFile($host, $group);
    system("echo \"$bkptimestamp\" > $lastBkpFile") unless $dryrun;
    logit( $host, $group, "Write lastBkpFile: $bkptimestamp \-\> $lastBkpFile" );

    return 1;
}

#################################
# Helper subroutines
#
sub eval_bkptimestamp {
    my ($host, $group) = @_;

    my $bkptimestamp = eval( $hosts{"$host-$group"}->{hostconfig}->{BKP_FOLDER} );
    chomp($bkptimestamp);

    return $bkptimestamp;
}

sub targetpath {
    my ($host, $group) = @_;

    my $hostconfig  = $hosts{"$host-$group"}->{hostconfig};
    my $target_path = "$hostconfig->{BKP_TARGET_PATH}/$hostconfig->{BKP_PREFIX}/$host";

    return $target_path;
}

sub finish_backupjob {
    my ($bkpjob) = @_;
    my $host         = $bkpjob->{'host'};
    my $group        = $bkpjob->{'group'};
    my $bkptimestamp = $bkpjob->{'bkptimestamp'};

    create_btrfs_snapshot( $host, $group, $bkptimestamp );
    createLastBkpFile( $host, $group, $bkptimestamp );
    hobbit_report( $host, $group );
    mail_report( $host, $group );
    logit( $host, $group, "Backup successful for host $host group $group!" );

    return 1;
}

#################################
# Reporting
#
sub db_report {
    my ($host, $group, $startstamp, $endstamp, $path, $targetpath ,$bkptimestamp, $errcode, @outlines) = @_;

    my %parse_log_keys = (
        'last backup'                 => 'LastBkp',
        'Number of files'             => 'NumOfFiles',
        'Number of files transferred' => 'NumOfFilesTrans',
        'Total file size'             => 'TotFileSize',
        'Total transferred file size' => 'TotFileSizeTrans',
        'Literal data'                => 'LitData',
        'Matched data'                => 'MatchData',
        'File list size'              => 'FileListSize',
        'File list generation time'   => 'FileListGenTime',
        'File list transfer time'     => 'FileListTransTime',
        'Total bytes sent'            => 'TotBytesSent',
        'Total bytes received'        => 'TotBytesRcv',
    );

    my %log_values;
    foreach my $logkey ( keys %parse_log_keys ) {
        $log_values{$parse_log_keys{$logkey}} = 'NULL';
    }

    foreach my $outline ( @outlines ) {
        next unless $outline =~ m/:/;
        chomp $outline;
        my ($key, $value) = split(': ', $outline);
        foreach my $logkey ( keys %parse_log_keys ) {
            if ( $logkey eq $key ) {
                $value =~ s/^\D*([\d.]+).*?$/$1/;
                $log_values{$parse_log_keys{$logkey}} = $value;
            }
        }
    }

    $path =~ s/'//g;    # rm quotes to avoid errors in sql syntax
    my $isSubfolderThread = $hosts{"$host-$group"}->{hostconfig}->{BKP_THREAD_SUBFOLDERS} ? 'true' : 'NULL';

    my $sql;
    $sql .= "INSERT INTO statistic (";
    $sql .= " BkpFromHost, BkpGroup,  BkpFromPath, BkpToHost, BkpToPath, LastBkp, isThread, ErrStatus, JobStatus, Start, Stop, ";
    $sql .= " NumOfFiles, NumOfFilesTrans, TotFileSize, TotFileSizeTrans, LitData, MatchData, ";
    $sql .= " FileListSize, FileListGenTime, FileListTransTime, TotBytesSent, TotBytesRcv ";
    $sql .= ") VALUES (";
    $sql .= "'$host', '$group', '$path', 'phd-bkp-gw', '$targetpath', '$bkptimestamp', ";
    $sql .= " $isSubfolderThread , '$errcode', 0, FROM_UNIXTIME('$startstamp'), FROM_UNIXTIME('$endstamp'), ";
    $sql .= "'$log_values{NumOfFiles}'  , '$log_values{NumOfFilesTrans}', ";
    $sql .= "'$log_values{TotFileSize}' , '$log_values{TotFileSizeTrans}', ";
    $sql .= "'$log_values{LitData}'     , '$log_values{MatchData}', ";
    $sql .= "'$log_values{FileListSize}', '$log_values{FileListGenTime}', '$log_values{FileListTransTime}', ";
    $sql .= "'$log_values{TotBytesSent}', '$log_values{TotBytesRcv}' ";
    $sql .= ")";
    logit( $host, $group, "SQL command: $sql" ) if ( $debuglevel >=2 );

    bangstat_db_connect($globalconfig{config_bangstat});
    my $sth = $BaNG::Reporting::bangstat_dbh->prepare($sql);
    $sth->execute() unless $dryrun;
    $sth->finish();

    logit( $host, $group, "Bangstat report sent.");

    return 1;
}

sub mail_report {
    my ($host, $group) = @_;

    my %mail = (
        To      => $globalconfig{report_to},
        From    => 'root@phys.ethz.ch',
        Subject => "Backup report of ($host-$group): success",
        Message => "* * * Backup report * * *\n\nBacking up: $host-$group\n\n* * * Backup successfull * * *\n",
    );
    unless ($dryrun) {
        sendmail(%mail) or logit( $host, $group, "mail_report error: $Mail::Sendmail::error" );
    }

    logit( $host, $group, "Mail report sent.");

    return 1;
}

sub hobbit_report {
    my ($host, $group)  = @_;

    my %RecentBackups = bangstat_recentbackups($host);
    my $RecentBackups = { RecentBackups => \%RecentBackups };

    my $topcolor = 'green';
    my $errcode;
    foreach my $key (keys %RecentBackups) {
        $errcode  = $RecentBackups{$key}[0]{ErrStatus};
        $topcolor = 'red' if ( $errcode gt 0 && !( $errcode eq 23 || $errcode eq 24 || $errcode eq 99 ));
    }

    my $STATUSTTL = 2160;     # (2160=>1.5d) Time in min until page becomes purple
    my $DATE      = `date`;
    chomp $DATE;

    my $hobbitreport = "status+$STATUSTTL $host.bkp $topcolor $DATE (TTL=$STATUSTTL min)\n";

    my $tt = Template->new(
        START_TAG  => '<%',
        END_TAG    => '%>',
        INCLUDE_PATH => "$prefix/views",
    );
    my $report;
    $tt->process('hobbitreport.tt', $RecentBackups, \$report)
        or logit( $host, $group, "Error generating hobbit report template: " . $tt->error() );
    $hobbitreport .= $report;

    send_hobbit_report($hobbitreport) unless $dryrun;
    logit( $host, $group, "Hobbit report sent.");

    return 1;
}

sub logit {
    my ($host, $group, $msg) = @_;

    my $timestamp  = strftime "%b %d %H:%M:%S", localtime;
    my $logdate    = strftime $globalconfig{global_log_date}, localtime;
    my $logfile    = "$globalconfig{'log_path'}/${host}-${group}_$logdate.log";
    my $logmessage = "$timestamp $host-$group : $msg";
    $logmessage   .= "\n" unless ( $logmessage =~ m/\n$/ );

    print $logmessage if $debug;

    unless ($dryrun) {
        open my $log, ">>", $logfile or print "Error opening logfile $logfile: $!\n";
        print {$log} $logmessage;
        close $log;
    }

    return 1;
}

#################################
# Command line arguments
#
sub parse_command_options {

    GetOptions(
        "help"        => sub { usage('') },
        "v|version"   => sub { usage("Current version number: $version") },
        "d|debug"     => \$debug,
        "n|dry-run"   => \$dryrun,
        "g|group=s"   => \$group_arg,
        "h|host=s"    => \$host_arg,
        "p|prefix=s"  => \$prefix_arg,
        "t|threads=i" => \$nthreads_arg,
        "w|wipe"      => \$wipe,
        "hobbit"      => \$hobbitonly,
    ) or usage("Invalid commmand line options.");
    usage("You must provide some arguments")    unless ( $host_arg || $group_arg );
    usage("Number of threads must be positive") if ( $nthreads_arg && $nthreads_arg <= 0 );

    $debug = 1 if $dryrun;

    return 1;
}

sub usage {
    my ($message) = @_;

    if ( defined $message && length $message ) {
        $message .= "\n"
            unless $message =~ /\n$/;
    }

    my $command = $0;
    $command    =~ s#^.*/##;

    print <<"EOF";
        $message
        Usage Examples:

        $command -h <hostname> -g <group>   # back up given host and group
        $command -h <hostname>              # back up all groups of given host
        $command -g <group>                 # back up all hosts of given group
        $command -v                         # show version number
        $command --help                     # show this help message

        Optional Arguments:

        -n              # dry-run without making changes
        -t <nr>         # number of threads, default: 1
        -p <path>       # override path to folder containing etc/
        -w              # wipe the backup
        --hobbit        # send only hobbit report
        -d              # show debugging messages

EOF
    exit 0;
}
