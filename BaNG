#!/usr/bin/env perl
#
# Copyright 2013 Patrick Schmid <schmid@phys.ethz.ch>, distributed under
# the terms of the GNU General Public License version 2 or later.
#
# Authors: Patrick Schmid <schmid@phys.ethz.ch> & Claude Becker <becker@phys.ethz.ch>
#
use strict;
use warnings;
use forks;
use Cwd qw( abs_path );
use File::Basename;
use Getopt::Long qw( :config no_auto_abbrev );
use IPC::Open3;
use Time::HiRes qw( gettimeofday );
use Thread::Queue;

use lib dirname( abs_path($0) ) . "/lib";
use BaNG::Hosts;
use BaNG::Config;
use BaNG::Reporting;
use BaNG::Wipe;

my $version = '3.1';
my $force;
my $wipe;
my $hobbitonly;
my $group_arg;
my $host_arg;
my $prefix_arg;
my $nthreads_arg;
my $debug_arg;
my $debuglevel_arg;
my $dryrun_arg;
my @queue;
my @subfolder_hosts;

#################################
# Main
#
parse_command_options();
get_global_config($prefix_arg);
cli_args_override_global_config();
get_host_config($host_arg, $group_arg);

foreach my $config ( sort keys %hosts ) {
    if ( $wipe ) {
        wipe( $hosts{$config}->{hostname}, $hosts{$config}->{group}, $force );
    } elsif ( $hobbitonly ) {
        my $host  = $hosts{$config}->{hostname};
        my $group = $hosts{$config}->{group};
        my %RecentBackups = bangstat_recentbackups($host);
        hobbit_report( $host, $group, %RecentBackups );
    } else {
        queue_backup( $hosts{$config}->{hostname}, $hosts{$config}->{group} );
    }
}

if ( !@queue ) {
    print "Exit because queue is empty.\n" if ( $globalconfig{debug} && !$wipe );
    exit 0;
}

start_threads();
finish_backupjob($_) foreach @subfolder_hosts;

exit 0;

#################################
# Queuing
#
sub queue_backup {
    my ($host, $group) = @_;

    logit( $host, $group, "Queueing backup for host $host group $group" );

    # make sure we are on the correct backup server
    return unless bkp_to_current_server($host, $group);

    # make sure backup is enabled
    return unless $hosts{"$host-$group"}->{hostconfig}->{BKP_ENABLED};

    # stop if trying to do bulk backup if it's not allowed
    return unless ( ($group_arg && $host_arg) || $hosts{"$host-$group"}->{hostconfig}->{BKP_BULK_ALLOW} );

    # check if last backup exists
    my $lastbkp = chkLastBkp($host, $group);
    my $jobid = create_jobid($host, $group);

    # make sure host is online
    my ($conn_status, $conn_msg) = chkClientConn( $host, $hosts{"$host-$group"}->{hostconfig}->{BKP_GWHOST} );
    logit( $host, $group, "chkClientConn: $conn_status, $conn_msg" );
    if ( !$conn_status ) {
        my $startstamp = time();
        my $endstamp = $startstamp;
        logit( $host, $group, "Error: host $host is offline" );
        db_report($jobid, $host, $group, $startstamp, $endstamp, $hosts{"$host-$group"}->{hostconfig}->{BKP_SOURCE_PARTITION}, targetpath($host, $group), $lastbkp, '0' , '-1', '');
        return 1;
    }

    my $bkptimestamp  = eval_bkptimestamp($host, $group);

    # get list of partitions to back up
    my (@src_part) = split( / /, $hosts{"$host-$group"}->{hostconfig}->{BKP_SOURCE_PARTITION} );
    logit( $host, $group, "Number of partitions: " . ($#src_part+1) . " ( @src_part )" );

    # optionally queue each subfolder of the partitions
    if ( $hosts{"$host-$group"}->{hostconfig}->{BKP_THREAD_SUBFOLDERS} ) {
        foreach my $part (@src_part) {
            queue_remote_subfolders( $jobid, $host, $group, $lastbkp, $bkptimestamp, $part );
        }

        my $bkpjob = {
            jobid        => $jobid,
            host         => $host,
            group        => $group,
            lastbkp      => $lastbkp,
            bkptimestamp => $bkptimestamp,
        };
        push( @subfolder_hosts, $bkpjob );

    } else {
        # queue list of partitions as a whole
        my $bkpjob = {
            jobid        => $jobid,
            host         => $host,
            group        => $group,
            path         => "@src_part",
            lastbkp      => $lastbkp,
            bkptimestamp => $bkptimestamp,
        };
        push( @queue, $bkpjob );
    }

    logit( $host, $group, "End of queueing backup of host $host group $group" );

    return 1;
}

sub queue_remote_subfolders {
    my ($jobid, $host, $group, $lastbkp, $bkptimestamp, $partition) = @_;
    $partition =~ s/://;

    my $remoteshell   = $hosts{"$host-$group"}->{hostconfig}->{BKP_RSYNC_RSHELL};
    my @remotedirlist = `$remoteshell $host find $partition -xdev -mindepth 1 -maxdepth 1`;
    logit( $host, $group, "eval subfolders command:\n @remotedirlist" );

    foreach my $remotedir (@remotedirlist) {
        chomp $remotedir;
        $remotedir =~ s| |\\ |g;

        my $bkpjob = {
            jobid        => $jobid,
            host         => $host,
            group        => $group,
            path         => ":'${remotedir}'",
            lastbkp      => $lastbkp,
            bkptimestamp => $bkptimestamp,
        };
        push( @queue, $bkpjob );
    }

    return 1;
}

#################################
# Threading
#
sub start_threads {

    # define number of threads
    my $nthreads;
    if ( $nthreads_arg ) {
        # If nthreads was defined by cli argument, use it
        $nthreads = $nthreads_arg;
        print "Using nthreads = $nthreads from command line argument\n" if $globalconfig{debug};
    } elsif ( $host_arg && $group_arg ) {
        # If no nthreads was given, and we back up a single host and group, get nthreads from its config
        $nthreads = $hosts{"$host_arg-$group_arg"}->{hostconfig}->{BKP_THREADS_DEFAULT};
        print "Using nthreads = $nthreads from $host_arg-$group_arg config file\n" if $globalconfig{debug};
    } else {
        $nthreads = 1;
    }

    my $Q = Thread::Queue->new;
    my @threads = map { threads->create( \&thread_work, $Q ) } (1 .. $nthreads);
    $Q->enqueue($_) for @queue;
    $Q->enqueue( (undef) x $nthreads );
    $_->join for @threads;

    return 1;
}

sub thread_work {
    my ($Q) = @_;

    while ( my $bkpjob = $Q->dequeue ) {
        my $tid          = threads->tid;
        my $jobid        = $bkpjob->{jobid};
        my $host         = $bkpjob->{host};
        my $group        = $bkpjob->{group};
        my $path         = $bkpjob->{path};
        my $lastbkp      = $bkpjob->{lastbkp};
        my $bkptimestamp = $bkpjob->{bkptimestamp};

        return unless createLockFile( $host, $group, $path );
        logit( $host, $group, "Thread $tid working on $host-$group ($path)" );
        execute_rsync( $jobid, $host, $group, $lastbkp, $bkptimestamp, $path );
        unless( $hosts{"$host-$group"}->{hostconfig}->{BKP_THREAD_SUBFOLDERS} ) {
            my $bkpjob = {
                jobid        => $jobid,
                host         => $host,
                group        => $group,
                lastbkp      => $lastbkp,
                bkptimestamp => $bkptimestamp,
            };
            finish_backupjob($bkpjob);
        }
        removeLockFile( $host, $group, $path );
    }

    return 1;
}

#################################
# Rsync
#
sub eval_rsync_options {
    my ($host, $group, $lastbkp) = @_;
    my $rsync_options = '';
    my $hostconfig    = $hosts{"$host-$group"}->{hostconfig};

    $rsync_options .= "--stats ";
    $rsync_options .= "-ax "            if $hostconfig->{BKP_RSYNC_ARCHIV};
    $rsync_options .= "-R "             if $hostconfig->{BKP_RSYNC_RELATIV};
    $rsync_options .= "-H "             if $hostconfig->{BKP_RSYNC_HLINKS};
    $rsync_options .= "--delete "       if $hostconfig->{BKP_RSYNC_DELETE};
    $rsync_options .= "--force "        if $hostconfig->{BKP_RSYNC_DELETE_FORCE};
    $rsync_options .= "--numeric-ids "  if $hostconfig->{BKP_RSYNC_NUM_IDS};
    $rsync_options .= "--inplace "      if $hostconfig->{BKP_RSYNC_INPLACE};
    $rsync_options .= "--acls "         if $hostconfig->{BKP_RSYNC_ACL};
    $rsync_options .= "--xattrs "       if $hostconfig->{BKP_RSYNC_XATTRS};
    $rsync_options .= "--no-D "         if $hostconfig->{BKP_RSYNC_NODEVICES};
    $rsync_options .= "-v "             if ($globalconfig{debug} && ($globalconfig{debuglevel} == 3));
    $rsync_options .= "--rsync-path=$hostconfig->{BKP_RSYNC_RSHELL_PATH} " if $hostconfig->{BKP_RSYNC_RSHELL_PATH};

    if ( $hostconfig->{BKP_EXCLUDE_FILE} ) {
        my $excludefile = "$globalconfig{path_excludes}/$hostconfig->{BKP_EXCLUDE_FILE}";
        if ( -e $excludefile ) {
            $rsync_options .= "--exclude-from=$globalconfig{path_excludes}/$hostconfig->{BKP_EXCLUDE_FILE} ";
        } else {
            logit( $host, $group, "Warning: could not find excludefile $excludefile." );
        }
    }

    # use links if told to and if lastbkp exists
    if ( ($hostconfig->{BKP_STORE_MODUS} eq 'links') && ($lastbkp ne 'nolastbkp') ) {
        $rsync_options .= "--link-dest " . targetpath($host, $group) . "/$lastbkp ";
    }

    if ( $hostconfig->{BKP_RSYNC_RSHELL} ) {
        if ( $hostconfig->{BKP_GWHOST} ) {
            $rsync_options .= "-e '$hostconfig->{BKP_RSYNC_RSHELL} $hostconfig->{BKP_GWHOST}' 'rsh $host'";
        } else {
            $rsync_options .= "-e $hostconfig->{BKP_RSYNC_RSHELL} $host";
        }
    }


    $rsync_options =~ s/\s+$//; # remove trailing space

    return $rsync_options;
}

sub eval_rsync_target {
    my ($host, $group, $bkptimestamp) = @_;

    my $rsync_target = targetpath($host, $group);

    if ( !-d $rsync_target ) {
        system("mkdir -p $rsync_target") unless $globalconfig{dryrun};
    }

    if ( $hosts{"$host-$group"}->{hostconfig}->{BKP_STORE_MODUS} eq 'snapshots' ) {
        $rsync_target .= "/current";

        if ( !-d $rsync_target ) {
            create_btrfs_subvolume( $host, $group, $rsync_target );
        }
    } else {
        $rsync_target .= "/$bkptimestamp";
    }

    return $rsync_target;
}

sub execute_rsync {
    my ($jobid, $host, $group, $lastbkp, $bkptimestamp, $path) = @_;

    $bkptimestamp  = eval_bkptimestamp($host, $group) unless $bkptimestamp;
    my $startstamp = time();

    my $rsync_cmd     = $globalconfig{path_rsync};
    my $rsync_options = eval_rsync_options($host,$group, $lastbkp);
    my $rsync_target  = eval_rsync_target($host, $group, $bkptimestamp);

    logit( $host, $group, "Rsync Command: $rsync_cmd $rsync_options$path $rsync_target" );
    logit( $host, $group, "Executing rsync for host $host group $group path $path" );

    local(*HIS_IN, *HIS_OUT, *HIS_ERR);
    $rsync_cmd = "echo $rsync_cmd" if $globalconfig{dryrun};
    my $rsyncpid = open3( *HIS_IN, *HIS_OUT, *HIS_ERR, "$rsync_cmd $rsync_options$path $rsync_target" );
    my @outlines = <HIS_OUT>;
    my @errlines = <HIS_ERR>;
    close HIS_IN;
    close HIS_OUT;
    close HIS_ERR;

    waitpid( $rsyncpid, 0 );

    logit( $host, $group, "Rsync STDOUT: @outlines" ) if ( @outlines && $globalconfig{debuglevel} >=2 );
    logit( $host, $group, "ERROR: Rsync STDERR: @errlines" ) if @errlines;
    logit( $host, $group, "ERROR: Rsync child exited with status of $?" ) if $?;

    my $errcode = 0;
    my $endstamp = time();

    if ( @errlines ){
        foreach my $errline (@errlines) {
            if ( $errline =~ /.* \(code (\d+)/ ) {
                $errcode = $1;
                logit( $host, $group, "Rsync errorcode: $errcode" );
            }
        }
    } else {
        logit( $host, $group, "Rsync successful for host $host group $group path $path" );
    }
    db_report($jobid, $host, $group, $startstamp, $endstamp, $path, targetpath($host, $group), $lastbkp, $errcode, '0', @outlines);

    return 1;
}

#################################
# Btrfs
#
sub create_btrfs_subvolume {
    my ( $host, $group, $path ) = @_;

    my $btrfs_subvolume_cmd = "$globalconfig{path_btrfs} subvolume create $path >/dev/null 2>&1";
    $btrfs_subvolume_cmd    = "echo $btrfs_subvolume_cmd" if $globalconfig{dryrun};

    logit( $host, $group, "Create btrfs subvolume: $btrfs_subvolume_cmd" );
    system($btrfs_subvolume_cmd) and logit( $host, $group, "ERROR: creating subvolume for $host-$group: $!" );

    return 1;
}

sub delete_btrfs_subvolume {
    my ( $host, $group, $path ) = @_;

    my $btrfs_subvolume_cmd = "$globalconfig{path_btrfs} subvolume delete $path >/dev/null 2>&1";
    $btrfs_subvolume_cmd    = "echo $btrfs_subvolume_cmd" if $globalconfig{dryrun};

    logit( $host, $group, "Delete btrfs subvolume: $btrfs_subvolume_cmd" );
    system($btrfs_subvolume_cmd) and logit( $host, $group, "ERROR: deleting subvolume for $host-$group: $!" );

    return 1;
}

sub create_btrfs_snapshot {
    my ( $host, $group, $bkptimestamp ) = @_;

    return unless ( $hosts{"$host-$group"}->{hostconfig}->{BKP_STORE_MODUS} eq 'snapshots' );

    my $btrfs_cmd             = $globalconfig{path_btrfs};
    my $btrfs_snapshot_source = targetpath( $host, $group ) . "/current";
    my $btrfs_snapshot_dest   = targetpath( $host, $group ) . "/" . $bkptimestamp;

    my $touch_current_cmd    = "touch $btrfs_snapshot_source >/dev/null 2>&1";
    $touch_current_cmd       = "echo $touch_current_cmd" if $globalconfig{dryrun};
    logit( $host, $group, "Touch current folder for host $host group $group" );
    system($touch_current_cmd) and logit( $host, $group, "ERROR: touching current folder for $host-$group: $!" );

    my $btrfs_snapshot_cmd    = "$btrfs_cmd subvolume snapshot -r $btrfs_snapshot_source $btrfs_snapshot_dest >/dev/null 2>&1";
    $btrfs_snapshot_cmd       = "echo $btrfs_snapshot_cmd" if $globalconfig{dryrun};
    logit( $host, $group, "Create btrfs snapshot for host $host group $group using $btrfs_snapshot_cmd" );
    system($btrfs_snapshot_cmd) and logit( $host, $group, "ERROR: creating snapshot for $host-$group: $!" );

    return 1;
}

#################################
# Wipe old backups
#
sub wipe {
    my ($host, $group, $force) = @_;

    # make sure we are on the correct backup server
    return unless bkp_to_current_server($host, $group);

    # make sure wipe is enabled
    return unless $hosts{"$host-$group"}->{hostconfig}->{WIPE_ENABLED};

    # stop if trying to do bulk wipe if it's not allowed
    return unless ( ($group_arg && $host_arg) || $hosts{"$host-$group"}->{hostconfig}->{WIPE_BULK_ALLOW} );

    logit( $host, $group, "Wipe host $host group $group" );

    my $bkpdir   = targetpath( $host, $group );
    my @backup_folders = `find $bkpdir -mindepth 1 -maxdepth 1 -type d -regex '${bkpdir}[0-9\./_]*'`;

    # count existing backups
    my $bkpkeep = 0;
    foreach my $type (qw( DAILY WEEKLY MONTHLY )) {
        $bkpkeep += $hosts{"$host-$group"}->{hostconfig}->{"WIPE_KEEP_$type"};
    }
    my $bkpcount = $#backup_folders + 1;

    logit( $host, $group, "Wipe existing: $bkpcount, keeping: $bkpkeep for host $host group $group" );

    # don't wipe if there are not enough bkps
    my $wipenum  = $bkpcount - $bkpkeep;
    if ( $wipenum <= 0 ) {
        logit( $host, $group, "Wipe nothing to do for host $host group $group" );
        return 1;
    }

    # get list of folders to wipe
    my @wipedirs = list_folders_to_wipe( $host, $group, $force, @backup_folders );

    # make sure list contains at least one folder
    if ( !@wipedirs ) {
        logit( $host, $group, "Wipe no folder to wipe for host $host group $group" );
        return 1;
    }

    # remove subvolumes or folders
    if ( $hosts{"$host-$group"}->{hostconfig}->{BKP_STORE_MODUS} eq 'snapshots' ) {
        delete_btrfs_subvolume( $host, $group, join(' ', @wipedirs) );
    } else {
        my $rmcmd = 'rm -Rf';
        $rmcmd = "echo $rmcmd" if $globalconfig{dryrun};
        foreach my $dir (@wipedirs) {
            logit( $host, $group, "Wipe $rmcmd $dir for host $host group $group" );
            system("$rmcmd $dir") and logit( $host, $group, "ERROR: removing folder $dir for $host-$group: $!" );
        }
    }

    logit( $host, $group, "Wipe successful of host $host group $group" );

    return 1;
}

#################################
# LastBkpFile
#
sub LastBkpFile {
    my ($host, $group) = @_;

    my $hostconfig  = $hosts{"$host-$group"}->{hostconfig};
    my $bkpdir      = "$hostconfig->{BKP_TARGET_PATH}/$hostconfig->{BKP_PREFIX}/$host";
    my $lastBkpFile = "$bkpdir/$hostconfig->{BKP_LASTBKP_FILE}";

    return $lastBkpFile;
}

sub chkLastBkp {
    my ($host, $group) = @_;

    my $lastbkp = 'nolastbkp';
    my $lastBkpFile = LastBkpFile($host, $group);

    if ( -e $lastBkpFile ) {
        $lastbkp = `cat $lastBkpFile`;
        chomp($lastbkp);
    }

    logit( $host, $group, "Found lastbkp = $lastbkp" );

    return $lastbkp;
}

sub createLastBkpFile {
    my ($host, $group, $bkptimestamp) = @_;

    my $lastBkpFile = LastBkpFile($host, $group);
    system("echo \"$bkptimestamp\" > $lastBkpFile") unless $globalconfig{dryrun};
    logit( $host, $group, "Write lastBkpFile: $bkptimestamp \-\> $lastBkpFile" );

    return 1;
}

#################################
# Helper subroutines
#
sub create_jobid {
    my ($host, $group) = @_;
    my ($s, $usec) = gettimeofday;
    my $jobid      = `$globalconfig{path_date} +"%Y%m%d%H%M%S"` . $usec;
    $jobid =~ s/\n//g;
    logit( $host, $group, "Created JobID: $jobid" );

    return $jobid;
}

sub eval_bkptimestamp {
    my ($host, $group) = @_;

    my $bkptimestamp = eval( $hosts{"$host-$group"}->{hostconfig}->{BKP_FOLDER} );
    chomp($bkptimestamp);

    return $bkptimestamp;
}

sub targetpath {
    my ($host, $group) = @_;

    my $hostconfig  = $hosts{"$host-$group"}->{hostconfig};
    my $target_path = "$hostconfig->{BKP_TARGET_PATH}/$hostconfig->{BKP_PREFIX}/$host";

    return $target_path;
}

sub finish_backupjob {
    my ($bkpjob) = @_;
    my $jobid        = $bkpjob->{'jobid'};
    my $host         = $bkpjob->{'host'};
    my $group        = $bkpjob->{'group'};
    my $bkptimestamp = $bkpjob->{'bkptimestamp'};
    my $lastbkp      = $bkpjob->{'lastbkp'};

    create_btrfs_snapshot( $host, $group, $bkptimestamp );
    createLastBkpFile( $host, $group, $bkptimestamp );
    bangstat_set_jobstatus( $jobid, $host, $group, $lastbkp, '1' );

    my %RecentBackups = bangstat_recentbackups($host);
    hobbit_report( $host, $group, %RecentBackups );
    mail_report( $host, $group, %RecentBackups );
    logit( $host, $group, "Backup successful for host $host group $group!" );

    return 1;
}

sub bkp_to_current_server {
    my ($host, $group) = @_;

    # make sure backup's target host matches local hostname
    my $bkp_target_host = $hosts{"$host-$group"}->{hostconfig}->{BKP_TARGET_HOST};
    if ( $bkp_target_host ne $servername && $bkp_target_host ne '*' ) {
        logit( $host, $group, "Skipping host $host group $group for server $bkp_target_host instead of $servername" ) if $globalconfig{debug};
        return 0;
    }

    return 1;
}

#################################
# Command line arguments
#
sub parse_command_options {

    GetOptions(
        "help"        => sub { usage('') },
        "v|version"   => sub { usage("Current version number: $version") },
        "d|debug"     => \$debug_arg,
        "n|dry-run"   => \$dryrun_arg,
        "g|group=s"   => \$group_arg,
        "h|host=s"    => \$host_arg,
        "p|prefix=s"  => \$prefix_arg,
        "t|threads=i" => \$nthreads_arg,
        "w|wipe"      => \$wipe,
        "force"       => \$force,
        "hobbit"      => \$hobbitonly,
    ) or usage("Invalid commmand line options.");
    usage("You must provide some arguments")    unless ( $host_arg || $group_arg );
    usage("Number of threads must be positive") if ( $nthreads_arg && $nthreads_arg <= 0 );

    $debug_arg = 1 if $dryrun_arg;

    return 1;
}

sub cli_args_override_global_config {

    $globalconfig{debug}      = $debug_arg      if $debug_arg;
    $globalconfig{debuglevel} = $debuglevel_arg if $debuglevel_arg;
    $globalconfig{dryrun}     = $dryrun_arg     if $dryrun_arg;

    return 1;
}

sub usage {
    my ($message) = @_;

    if ( defined $message && length $message ) {
        $message .= "\n"
            unless $message =~ /\n$/;
    }

    my $command = $0;
    $command    =~ s#^.*/##;

    print <<"EOF";
        $message
        Usage Examples:

        $command -h <hostname> -g <group>   # back up given host and group
        $command -h <hostname>              # back up all groups of given host
        $command -g <group>                 # back up all hosts of given group
        $command -v                         # show version number
        $command --help                     # show this help message

        Optional Arguments:

        -n              # dry-run without making changes
        -t <nr>         # number of threads, default: 1
        -p <path>       # override path to folder containing etc/
        -w              # wipe the backup
        -w --force      # forcing wipe the backup (override auto_wipe_limit)
        --hobbit        # send only hobbit report
        -d              # show debugging messages

EOF
    exit 0;
}
