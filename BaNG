#!/usr/bin/env perl
use strict;
use warnings;
use forks;
use Cwd qw( abs_path );
use Date::Parse;
use File::Basename;
use Getopt::Long qw( :config no_auto_abbrev );
use Thread::Queue;

use lib dirname( abs_path($0) ) . '/lib';
use BaNG::Config;
use BaNG::BackupServer;
use BaNG::Reporting;
use BaNG::TM_rsync;
use BaNG::TM_tar;
use BaNG::BTRFS;
use BaNG::Wipe;

my $version = '3.6';
my $prefix_arg;
my ($host_arg, $group_arg, $subgroup_arg, $nthreads_arg, $bkpmode_arg);
my ($cron, $wipe, $xymononly);
my ($initial, $force, $noreport, $missingonly);
my ($taskid, $taskmeta);
my ($verbose_arg, $vv_arg, $vvv_arg);
my $dryrun_arg;
my %finishable_bkpjobs;

#################################
# Main
#
parse_command_options();
get_serverconfig($prefix_arg);
cli_args_override_global_config();

print "BaNG run in $serverconfig{bkpmode} mode!\n" if $serverconfig{verbose};

$cron = $ENV{'BaNG_Cron'} || "0";
print "Run as Cron: $cron\n" if $serverconfig{verbose};

$taskid = create_timeid( $host_arg, $group_arg );

bangstat_set_taskmeta( $taskid, $host_arg, $group_arg, $cron, $taskmeta) unless ( $wipe || $xymononly );

if ( $serverconfig{bkpmode} eq "rsync") {

    get_host_config( $host_arg, $group_arg );

    foreach my $config ( sort keys %hosts ) {
        if ($wipe) {
            wipe( $hosts{$config}->{hostname}, $hosts{$config}->{group}, $taskid, $force );
        } elsif ($xymononly) {
            my $host          = $hosts{$config}->{hostname};
            my $group         = $hosts{$config}->{group};
            my %RecentBackups = bangstat_recentbackups($host);
            xymon_report( $taskid, $host, $group, %RecentBackups );
        } else {
            queue_rsync_backup( $host_arg, $group_arg, $hosts{$config}->{hostname}, $hosts{$config}->{group}, $initial, $missingonly, $noreport, $taskid );
        }
    }
} elsif ( $serverconfig{bkpmode} eq "tar" ) {

    get_lts_config( $group_arg, $subgroup_arg );

    print "TAR mode work\n" if $serverconfig{verbose};
    queue_tar_backup( $group_arg, $subgroup_arg, $noreport, $taskid );
}


if ( !@queue ) {
    print "Exit because queue is empty.\n" if ( $serverconfig{verbose} && !$wipe );
    exit 0;
}

reorder_queue_by_priority( $taskid, $host_arg, $group_arg );
run_threads();
foreach my $finishable_bkpjob (sort keys %finishable_bkpjobs) {
    finish_backupjob($finishable_bkpjobs{$finishable_bkpjob});
}
logit( $taskid, $host_arg, $group_arg, "Task $taskid finished!" );

exit 0;

#################################
# Threading
#
sub run_threads {

    # define number of threads
    my $nthreads;
    if ($nthreads_arg) {

        # If nthreads was defined by cli argument, use it
        $nthreads = $nthreads_arg;
        print "Using nthreads = $nthreads from command line argument\n" if $serverconfig{verbose};
    } elsif ( $host_arg && $group_arg ) {

        # If no nthreads was given, and we back up a single host and group, get nthreads from its config
        $nthreads = $hosts{"$host_arg-$group_arg"}->{hostconfig}->{BKP_THREADS_DEFAULT};
        print "Using nthreads = $nthreads from $host_arg-$group_arg config file\n" if $serverconfig{verbose};
    } else {
        $nthreads = 1;
    }
    my $Q = Thread::Queue->new;
    my @threads = map { threads->create( \&thread_work, $Q ) } ( 1 .. $nthreads );
    $Q->enqueue($_) for @queue;
    $Q->enqueue( (undef) x $nthreads );

    foreach my $thread (@threads) {
        my (@finishable_bkpjobs_in_thread) = $thread->join;

        # Merge bkpjobs returned by this thread with already known jobs
        foreach my $bkpjob (@finishable_bkpjobs_in_thread) {
            if ( exists $finishable_bkpjobs{$bkpjob->{jobid}} ) {
                $finishable_bkpjobs{$bkpjob->{jobid}}->{has_failed} = 1 if $bkpjob->{has_failed};
                $finishable_bkpjobs{$bkpjob->{jobid}}->{dosnapshot} = 1 if $bkpjob->{dosnapshot};
            } else {
                $finishable_bkpjobs{$bkpjob->{jobid}} = $bkpjob;
            }
            # Push unique rsync errors to array
            unless( grep { $_ == $bkpjob->{rsync_err} } @{ $finishable_bkpjobs{$bkpjob->{jobid}}->{rsync_errs} } ) {
                push( @{ $finishable_bkpjobs{$bkpjob->{jobid}}->{rsync_errs} }, $bkpjob->{rsync_err} );
            }
        }
    }

    return 1;
}

sub thread_work {
    my ($Q) = @_;
    my @finishable_bkpjobs_in_thread;

    while ( my $bkpjob = $Q->dequeue ) {
        my $tid            = threads->tid;
        my $jobid          = $bkpjob->{jobid};
        my $host           = $bkpjob->{host};
        my $group          = $bkpjob->{group};
        my $path           = $bkpjob->{path};
        my $bkptimestamp   = $bkpjob->{bkptimestamp};
        my $srcfolder      = $bkpjob->{srcfolder};
        my $dosnapshot     = $bkpjob->{'dosnapshot'};
        my $exclsubfolders = $bkpjob->{'exclsubfolders'} || 0;

        my $random_integer = int( rand(10) ) + 1;
        $random_integer = 0 if ( $dryrun_arg || not $hosts{"$host-$group"}->{hostconfig}->{BKP_THREAD_SUBFOLDERS} );

        return unless create_lockfile( $taskid, $host, $group, $path );
        writeto_lockfile( $taskid, $host, $group, $path, "cron", $cron);
        logit( $taskid, $host, $group, "Thread $tid sleep $random_integer sec. for $host-$group ($path)" );
        sleep($random_integer);
        logit( $taskid, $host, $group, "Thread $tid working on $host-$group ($path)" );
        my $rsync_err = execute_rsync( $taskid, $jobid, $noreport, $host, $group, $bkptimestamp, $path, $srcfolder ,$exclsubfolders );
        logit( $taskid, $host, $group, "Thread $tid finished with $host-$group ($path) ErrCode: $rsync_err" );
        my $bkpjob = {
            jobid        => $jobid,
            host         => $host,
            group        => $group,
            bkptimestamp => $bkptimestamp,
            dosnapshot   => $dosnapshot,
            rsync_err    => $rsync_err,
            has_failed   => check_rsync_status( $rsync_err ),
        };
        push(@finishable_bkpjobs_in_thread, $bkpjob);
        remove_lockfile( $taskid, $host, $group, $path );
    }

    return (@finishable_bkpjobs_in_thread);
}

#################################
# Helper subroutines
#
sub finish_backupjob {
    my ($bkpjob)     = @_;
    my $jobid        = $bkpjob->{'jobid'};
    my $host         = $bkpjob->{'host'};
    my $group        = $bkpjob->{'group'};
    my $bkptimestamp = $bkpjob->{'bkptimestamp'};
    my $dosnapshot   = $bkpjob->{'dosnapshot'};
    my $has_failed   = $bkpjob->{'has_failed'};
    my $rsync_err    = join(', ', sort @{ $bkpjob->{'rsync_errs'} });
    my @rsync_pass   = @{ $serverconfig{'rsync_err_ok'} };

    if (( $hosts{"$host-$group"}->{hostconfig}->{BKP_STORE_MODUS} eq 'snapshots' ) &&  ( $dosnapshot )) {
        my $rsync_target = targetpath( $host, $group );
        create_btrfs_snapshot( $host, $group, $bkptimestamp, $taskid, $rsync_target);
        if ( $has_failed ) {
            logit( $taskid, $host, $group, "rsync in snapshot-mode failed with code $rsync_err for host $host group $group" ) if $serverconfig{verbose};
            rename_failed_backup( $taskid, $host, $group, $bkptimestamp );
        } else {
            logit( $taskid, $host, $group, "rsync in snapshot-mode successfully finished with (code $rsync_err) for host $host group $group" ) if $serverconfig{verbose};
        }
    }
    if ( $hosts{"$host-$group"}->{hostconfig}->{BKP_STORE_MODUS} eq 'links' ) {
        if ( $has_failed ) {
            logit( $taskid, $host, $group, "rsync in links-mode failed with code $rsync_err for host $host group $group" ) if $serverconfig{verbose};
            rename_failed_backup( $taskid, $host, $group, $bkptimestamp );
        } else {
            logit( $taskid, $host, $group, "rsync in links-mode successfully finished with (code $rsync_err) for host $host group $group" ) if $serverconfig{verbose};
            create_link_current( $host, $group, $bkptimestamp );
        }
    }

    # report finished job to DB, jobstatus => 2
    bangstat_finish_backupjob( $taskid, $jobid, $host, $group, '2' ) unless $noreport;

    my %RecentBackups = bangstat_recentbackups($host);
    unless ($noreport) {
        xymon_report( $taskid, $host, $group, %RecentBackups );
        mail_report( $taskid, $host, $group, %RecentBackups ) if $serverconfig{report_to};
    }
    logit( $taskid, $host, $group, "Backup successful for host $host group $group!" );

    remove_generic_exclude_file($taskid, $host, $group, $jobid) if $hosts{"$host-$group"}->{hostconfig}->{BKP_THREAD_SUBFOLDERS};

    return 1;
}

#################################
# Command line arguments
#
sub parse_command_options {

    GetOptions(
        'help'             => sub { usage('') },
        'version'          => sub { usage("Current version number: $version") },
        'v|verbose'        => \$verbose_arg,
        'vv'               => \$vv_arg,
        'vvv'              => \$vvv_arg,
        'bkpmode=s'        => \$bkpmode_arg,
        'n|dry-run'        => \$dryrun_arg,
        'g|group=s'        => \$group_arg,
        'sg|subgroup=s'    => \$subgroup_arg,
        'h|host=s'         => \$host_arg,
        'p|prefix=s'       => \$prefix_arg,
        't|threads=i'      => \$nthreads_arg,
        'w|wipe'           => \$wipe,
        'initial'          => \$initial,
        'force'            => \$force,
        'missingonly'      => \$missingonly,
        'label=s'          => \$taskmeta,
        'xymon'            => \$xymononly,
        'noreport'         => \$noreport,
    ) or usage('Invalid commmand line options.');
    usage('You must provide some arguments') unless ( $host_arg || $group_arg );
    usage('Number of threads must be positive') if ( $nthreads_arg && $nthreads_arg <= 0 );
    usage('Wrong Backup Mode, please use rsync or tar') unless ( !defined $bkpmode_arg  || ($bkpmode_arg eq "rsync" || $bkpmode_arg eq "tar" ));

    $verbose_arg = 1 if ( $dryrun_arg || $vv_arg || $vvv_arg );

    return 1;
}

sub cli_args_override_global_config {

    $serverconfig{bkpmode}      = $bkpmode_arg if $bkpmode_arg;
    $serverconfig{verbose}      = $verbose_arg if $verbose_arg;
    $serverconfig{dryrun}       = $dryrun_arg  if $dryrun_arg;
    $serverconfig{verboselevel} = 2            if $vv_arg;
    $serverconfig{verboselevel} = 3            if $vvv_arg;

    return 1;
}

sub usage {
    my ($message) = @_;

    if ( defined $message && length $message ) {
        $message .= "\n"
            unless $message =~ /\n$/;
    }

    my $command = $0;
    $command =~ s#^.*/##;

    print <<"EOF";
        $message
        Usage Examples:

        $command -h <host> -g <group> # back up given host and group
        $command -h <host>            # back up all groups of given host
        $command -g <group>           # back up all hosts of given group

        $command -g <group> -sg <subgroup> --bkpmode tar  # make LTS backups

        $command --help               # show this help message
        $command --version            # show version number and help

        Optional Arguments:

        -t <nr>                     # number of threads, default: 1
        -p <path>                   # override path to folder containing etc/
        -w | --wipe                 # wipe the backup
        -w --force                  # forcing wipe the backup (override auto_wipe_limit)
        --bkpmode <rsync|tar>       # select backup mode (rsync / tar), default: rsync
        -sg | --subgroup <subgroup> # needed for bkpmode tar
        --initial                   # create nonexisting backup targets
        --missingonly               # backup only hosts that were not backed up recently
        --label <string>            # set a label for this task
        --xymon                     # send only xymon report
        --noreport                  # do not send any report
        -v | -vv | -vvv             # verbose mode to include debugging messages of level 1-3
        -n                          # dry-run without making changes (implies verbose)

EOF

    exit 0;
}
