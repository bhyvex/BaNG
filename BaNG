#!/usr/bin/env perl
#
# Copyright 2013 Patrick Schmid <schmid@phys.ethz.ch>, distributed under
# the terms of the GNU General Public License version 2 or later.
#
# Authors: Patrick Schmid <schmid@phys.ethz.ch> & Claude Becker <becker@phys.ethz.ch>
#
use strict;
use warnings;
use forks;
use Cwd qw( abs_path );
use Date::Parse;
use File::Basename;
use Getopt::Long qw( :config no_auto_abbrev );
use IPC::Open3;
use Time::HiRes qw( gettimeofday );
use Thread::Queue;

use lib dirname( abs_path($0) ) . "/lib";
use BaNG::Hosts;
use BaNG::Common;
use BaNG::Config;
use BaNG::Reporting;
use BaNG::Wipe;

my $version = '3.3';
my $force;
my $wipe;
my $cleanup;
my $hobbitonly;
my $missingonly;
my $group_arg;
my $host_arg;
my $prefix_arg;
my $nthreads_arg;
my $finallysnapshots;
my $debug_arg;
my $debuglevel_arg;
my $dryrun_arg;
my @queue;
my @finally_snapshots;

#################################
# Main
#
parse_command_options();
get_serverconfig($prefix_arg);
cli_args_override_global_config();

my $taskid = create_timeid($host_arg, $group_arg);

get_host_config($host_arg, $group_arg);

foreach my $config ( sort keys %hosts ) {
    if ( $wipe ) {
        wipe( $taskid, $hosts{$config}->{hostname}, $hosts{$config}->{group}, $force );
    } elsif ( $cleanup ) {
        print "Let's go!\n";
    } elsif ( $hobbitonly ) {
        my $host  = $hosts{$config}->{hostname};
        my $group = $hosts{$config}->{group};
        my %RecentBackups = bangstat_recentbackups($host);
        hobbit_report( $taskid, $host, $group, %RecentBackups );
    } else {
        queue_backup( $taskid, $hosts{$config}->{hostname}, $hosts{$config}->{group} );
    }
}

if ( !@queue ) {
    print "Exit because queue is empty.\n" if ( $serverconfig{debug} && !$wipe );
    exit 0;
}

reorder_queue_by_priority( $taskid, $host_arg, $group_arg );
start_threads();
finish_backupjob($_) foreach @finally_snapshots;

exit 0;

#################################
# Queuing
#
sub reorder_queue_by_priority {
    my ($taskid, $host, $group) = @_;
    my @prio_queue;
    my @prio_queue_sorted;
    $host  ||= "SERVER";
    $group ||= "GLOBAL";

    logit( $taskid, $host, $group, "reorder queue by priority!" );

    # add priority information to all queued backup jobs
    foreach my $bkpjob (@queue) {
        my $host  = $bkpjob->{host};
        my $group = $bkpjob->{group};
        my $path  = $bkpjob->{path};
        $path =~ s/[':]//g;

        my $prio = $hosts{"$host-$group"}->{hostconfig}->{BKP_PRIORITY}->{"$path"} || 0;
        $bkpjob->{priority} = $prio;
        print "$path set priority to $prio\n" if $serverconfig{debug};
        push( @prio_queue, $bkpjob );
    }

    # reorder queue by priority
    foreach my $bkpjob ( sort { $a->{priority} <=> $b->{priority} } @queue) {
        print "$bkpjob->{priority} $bkpjob->{path}\n" if $serverconfig{debug};
        push( @prio_queue_sorted, $bkpjob );
    }

    if ($#queue == $#prio_queue_sorted ) {
        @queue = @prio_queue_sorted;
    } else {
        logit( $taskid, $host, $group, "ERROR: reorder_queue_by_priority queue lengths don't match!" );
    }

    return 1;
}

sub queue_backup {
    my ($taskid, $host, $group) = @_;
    my $jobid;

    logit( $taskid, $host, $group, "Queueing backup for host $host group $group" );

    # make sure we are on the correct backup server
    return unless bkp_to_current_server($taskid, $host, $group);

    # make sure backup is enabled
    return unless $hosts{"$host-$group"}->{hostconfig}->{BKP_ENABLED};

    # stop if trying to do bulk backup if it's not allowed
    return unless ( ($group_arg && $host_arg) || $hosts{"$host-$group"}->{hostconfig}->{BKP_BULK_ALLOW} );

    # check if last backup exists
    my $lastbkp = check_last_bkp($taskid, $host, $group);

    # if missingonly, don't queue host if we had a backup within the last 20 hours
    if ( $missingonly && $lastbkp =~ qr{ (?<date>[^_]*) _ (?<HH>\d\d) (?<MM>\d\d) (?<SS>\d\d) }x ) {
        my $lastbkpepoch = str2time( "$+{date} $+{HH}:$+{MM}:$+{SS}" );
        if ( (time - $lastbkpepoch) < 20 * 3600 ) {
            logit( $taskid, $host, $group, "Skipping because recent backup found for host $host group $group" );
            return 1;
        }
    }

    # make sure host is online
    my ($conn_status, $conn_msg) = check_client_connection( $host, $hosts{"$host-$group"}->{hostconfig}->{BKP_GWHOST} );
    logit( $taskid, $host, $group, "check_client_connection: $conn_status, $conn_msg" );
    if ( !$conn_status ) {
        my $startstamp = time();
        my $endstamp = $startstamp;
        $jobid = create_timeid($host, $group, $taskid);
        logit( $taskid, $host, $group, "Error: host $host is offline" );
        db_report($taskid, $jobid, $host, $group, $startstamp, $endstamp, $hosts{"$host-$group"}->{hostconfig}->{BKP_SOURCE_PARTITION}, targetpath($host, $group), $lastbkp, '0' , '-1', '');
        return 1;
    }

    my $bkptimestamp  = eval_bkptimestamp($host, $group);

    # get list of partitions to back up
    my (@src_part) = split( / /, $hosts{"$host-$group"}->{hostconfig}->{BKP_SOURCE_PARTITION} );
    logit( $taskid, $host, $group, "Number of partitions: " . ($#src_part+1) . " ( @src_part )" );

    # optionally queue each subfolder of the partitions
    if ( $hosts{"$host-$group"}->{hostconfig}->{BKP_THREAD_SUBFOLDERS} ) {

        my $dosnapshot = 0;
        my $numPart = @src_part;

        foreach my $part (@src_part) {
            $jobid = create_timeid($host, $group, $taskid);

            $numPart --;
            if ( $numPart == 0 ) {
                $dosnapshot = 1;
            }

            queue_remote_subfolders( $taskid, $jobid, $host, $group, $lastbkp, $bkptimestamp, $dosnapshot, $part );
        }
    } else {
        # queue list of partitions as a whole
        $jobid = create_timeid($host, $group, $taskid);
        my $bkpjob = {
            taskid       => $taskid,
            jobid        => $jobid,
            host         => $host,
            group        => $group,
            path         => "@src_part",
            lastbkp      => $lastbkp,
            bkptimestamp => $bkptimestamp,
            dosnapshot   => "1",
        };
        push( @queue, $bkpjob );
        push( @finally_snapshots, $bkpjob ) if ( $finallysnapshots );
    }

    logit( $taskid, $host, $group, "End of queueing backup of host $host group $group" );

    return 1;
} 

sub queue_remote_subfolders {
    my ($taskid, $jobid, $host, $group, $lastbkp, $bkptimestamp, $dosnapshot, $partition) = @_;
    $partition =~ s/://;

    my $remoteshell   = $hosts{"$host-$group"}->{hostconfig}->{BKP_RSYNC_RSHELL};
    my @remotedirlist = `$remoteshell $host find $partition -xdev -mindepth 1 -maxdepth 1 | sort`;

    # if @remotedirlist empty (rsh troubles?) then use the $partition
    if ( $#remotedirlist == -1 ){
        push( @remotedirlist, $partition );
        logit( $taskid, $host, $group, "ERROR: eval subfolders command failed, use now with:\n @remotedirlist" );
    } else {
        logit( $taskid, $host, $group, "eval subfolders command:\n @remotedirlist" );
    }

    foreach my $remotedir (@remotedirlist) {
        chomp $remotedir;
        $remotedir =~ s| |\\ |g;
        $remotedir =~ s|\(|\\\(|g;
        $remotedir =~ s|\)|\\\)|g;

        my $bkpjob = {
            taskid       => $taskid,
            jobid        => $jobid,
            host         => $host,
            group        => $group,
            path         => ":'${remotedir}'",
            lastbkp      => $lastbkp,
            bkptimestamp => $bkptimestamp,
            dosnapshot   => "0",
        };
        push( @queue, $bkpjob );
    }
    my $bkpjob = {
        taskid       => $taskid,
        jobid        => $jobid,
        host         => $host,
        group        => $group,
        lastbkp      => $lastbkp,
        bkptimestamp => $bkptimestamp,
        dosnapshot   => $dosnapshot,
    };
    push( @finally_snapshots, $bkpjob );

    return 1;
}

#################################
# Threading
#
sub start_threads {
    # define number of threads
    my $nthreads;
    if ( $nthreads_arg ) {
        # If nthreads was defined by cli argument, use it
        $nthreads = $nthreads_arg;
        print "Using nthreads = $nthreads from command line argument\n" if $serverconfig{debug};
    } elsif ( $host_arg && $group_arg ) {
        # If no nthreads was given, and we back up a single host and group, get nthreads from its config
        $nthreads = $hosts{"$host_arg-$group_arg"}->{hostconfig}->{BKP_THREADS_DEFAULT};
        print "Using nthreads = $nthreads from $host_arg-$group_arg config file\n" if $serverconfig{debug};
    } else {
        $nthreads = 1;
    }

    my $Q = Thread::Queue->new;
    my @threads = map { threads->create( \&thread_work, $Q ) } (1 .. $nthreads);
    $Q->enqueue($_) for @queue;
    $Q->enqueue( (undef) x $nthreads );
    $_->join for @threads;

    return 1;
}

sub thread_work {
    my ($Q) = @_;


    while ( my $bkpjob = $Q->dequeue ) {
        my $tid          = threads->tid;
        my $taskid       = $bkpjob->{taskid};
        my $jobid        = $bkpjob->{jobid};
        my $host         = $bkpjob->{host};
        my $group        = $bkpjob->{group};
        my $path         = $bkpjob->{path};
        my $lastbkp      = $bkpjob->{lastbkp};
        my $bkptimestamp = $bkpjob->{bkptimestamp};
        my $dosnapshot   = $bkpjob->{'dosnapshot'};

        my $random_integer = int(rand(10)) + 1;

        return unless create_lockfile( $taskid, $host, $group, $path );
        logit( $taskid, $host, $group, "Thread $tid sleep $random_integer sec. for $host-$group ($path)" );
        sleep($random_integer);
        logit( $taskid, $host, $group, "Thread $tid working on $host-$group ($path)" );
        execute_rsync( $taskid, $jobid, $host, $group, $lastbkp, $bkptimestamp, $path );
        logit( $taskid, $host, $group, "Thread $tid finished with $host-$group ($path)" );
        unless( ( $hosts{"$host-$group"}->{hostconfig}->{BKP_THREAD_SUBFOLDERS} ) || ( $finallysnapshots ) ) {
            my $bkpjob = {
                taskid       => $taskid,
                jobid        => $jobid,
                host         => $host,
                group        => $group,
                lastbkp      => $lastbkp,
                bkptimestamp => $bkptimestamp,
                dosnapshot   => $dosnapshot,
            };
            finish_backupjob($bkpjob);
        }
        remove_lockfile( $taskid, $host, $group, $path );
    }

    return 1;
}

#################################
# Rsync
#
sub eval_rsync_options {
    my ($taskid, $host, $group, $lastbkp) = @_;
    my $rsync_options = '';
    my $hostconfig    = $hosts{"$host-$group"}->{hostconfig};

    $rsync_options .= "--stats ";
    $rsync_options .= "-a "             if $hostconfig->{BKP_RSYNC_ARCHIV};
    $rsync_options .= "-x "             if $hostconfig->{BKP_RSYNC_ONE_FS};
    $rsync_options .= "-R "             if $hostconfig->{BKP_RSYNC_RELATIV};
    $rsync_options .= "-H "             if $hostconfig->{BKP_RSYNC_HLINKS};
    $rsync_options .= "-W "             if $hostconfig->{BKP_RSYNC_WHOLEFILE};
    $rsync_options .= "--delete "       if $hostconfig->{BKP_RSYNC_DELETE};
    $rsync_options .= "--force "        if $hostconfig->{BKP_RSYNC_DELETE_FORCE};
    $rsync_options .= "--numeric-ids "  if $hostconfig->{BKP_RSYNC_NUM_IDS};
    $rsync_options .= "--inplace "      if $hostconfig->{BKP_RSYNC_INPLACE};
    $rsync_options .= "--acls "         if $hostconfig->{BKP_RSYNC_ACL};
    $rsync_options .= "--xattrs "       if $hostconfig->{BKP_RSYNC_XATTRS};
    $rsync_options .= "--no-D "         if $hostconfig->{BKP_RSYNC_NODEVICES};
    $rsync_options .= "-v "             if ($serverconfig{debug} && ($serverconfig{debuglevel} == 3));
    $rsync_options .= "--rsync-path=$hostconfig->{BKP_RSYNC_RSHELL_PATH} " if $hostconfig->{BKP_RSYNC_RSHELL_PATH};

    if ( $hostconfig->{BKP_EXCLUDE_FILE} ) {
        my $excludefile = "$serverconfig{path_excludes}/$hostconfig->{BKP_EXCLUDE_FILE}";
        if ( -e $excludefile ) {
            $rsync_options .= "--exclude-from=$serverconfig{path_excludes}/$hostconfig->{BKP_EXCLUDE_FILE} ";
        } else {
            logit( $taskid, $host, $group, "Warning: could not find excludefile $excludefile." );
        }
    }

    # use links if told to and if lastbkp exists
    if ( ($hostconfig->{BKP_STORE_MODUS} eq 'links') && ($lastbkp ne 'nolastbkp') ) {
        $rsync_options .= "--link-dest " . targetpath($host, $group) . "/$lastbkp ";
    }

    if ( $hostconfig->{BKP_RSYNC_RSHELL} ) {
        if ( $hostconfig->{BKP_GWHOST} ) {
            $rsync_options .= "-e '$hostconfig->{BKP_RSYNC_RSHELL} $hostconfig->{BKP_GWHOST}' 'rsh $host'";
        } else {
            $rsync_options .= "-e $hostconfig->{BKP_RSYNC_RSHELL} $host";
        }
    }


    $rsync_options =~ s/\s+$//; # remove trailing space

    return $rsync_options;
}

sub eval_rsync_target {
    my ($host, $group, $bkptimestamp) = @_;

    my $rsync_target = targetpath($host, $group);

    if ( !-d $rsync_target ) {
        system("mkdir -p $rsync_target") unless $serverconfig{dryrun};
    }

    if ( $hosts{"$host-$group"}->{hostconfig}->{BKP_STORE_MODUS} eq 'snapshots' ) {
        $rsync_target .= "/current";

        if ( !-d $rsync_target ) {
            create_btrfs_subvolume( $taskid, $host, $group, $rsync_target );
        }
    } else {
        $rsync_target .= "/$bkptimestamp";
    }

    return $rsync_target;
}

sub execute_rsync {
    my ($taskid, $jobid, $host, $group, $lastbkp, $bkptimestamp, $path) = @_;

    $bkptimestamp  = eval_bkptimestamp($host, $group) unless $bkptimestamp;
    my $startstamp = time();

    my $nocache = "";
    if ( $hosts{"$host-$group"}->{hostconfig}->{NOCACHE_ENABLED} ) {
           if (-e $serverconfig{path_nocache} ) {
                $nocache = $serverconfig{path_nocache} . " ";
            } else {
                logit( $taskid, $host, $group, "NOCACHE selected but command $serverconfig{path_nocache} not found!" );
            }
    }

    my $rsync_cmd     = $nocache . $serverconfig{path_rsync};
    my $rsync_options = eval_rsync_options($taskid, $host, $group, $lastbkp);
    my $rsync_target  = eval_rsync_target($host, $group, $bkptimestamp);

    logit( $taskid, $host, $group, "Rsync Command: $rsync_cmd $rsync_options$path $rsync_target" );
    logit( $taskid, $host, $group, "Executing rsync for host $host group $group path $path" );

    local(*HIS_IN, *HIS_OUT, *HIS_ERR);
    $rsync_cmd = "echo $rsync_cmd" if $serverconfig{dryrun};
    my $rsyncpid = open3( *HIS_IN, *HIS_OUT, *HIS_ERR, "$rsync_cmd $rsync_options$path $rsync_target" );
    my @outlines = <HIS_OUT>;
    my @errlines = <HIS_ERR>;
    close HIS_IN;
    close HIS_OUT;
    close HIS_ERR;

    waitpid( $rsyncpid, 0 );

    logit( $taskid, $host, $group, "Rsync STDOUT: @outlines" ) if ( @outlines && $serverconfig{debuglevel} >=2 );
    logit( $taskid, $host, $group, "ERROR: Rsync STDERR: @errlines" ) if @errlines;
    logit( $taskid, $host, $group, "ERROR: Rsync child exited with status of $?" ) if $?;

    my $errcode = 0;
    my $endstamp = time();

    if ( @errlines ){
        foreach my $errline (@errlines) {
            if ( $errline =~ /.* \(code (\d+)/ ) {
                $errcode = $1;
                logit( $taskid, $host, $group, "Rsync errorcode: $errcode" );
            }
        }
    } else {
        logit( $taskid, $host, $group, "Rsync successful for host $host group $group path $path" );
    }
    db_report($taskid, $jobid, $host, $group, $startstamp, $endstamp, $path, targetpath($host, $group), $lastbkp, $errcode, '0', @outlines);

    return 1;
}

#################################
# Btrfs
#
sub create_btrfs_subvolume {
    my ( $taskid, $host, $group, $path ) = @_;

    my $btrfs_subvolume_cmd = "$serverconfig{path_btrfs} subvolume create $path >/dev/null 2>&1";
    $btrfs_subvolume_cmd    = "echo $btrfs_subvolume_cmd" if $serverconfig{dryrun};

    logit( $taskid, $host, $group, "Create btrfs subvolume: $btrfs_subvolume_cmd" );
    system($btrfs_subvolume_cmd) and logit( $taskid, $host, $group, "ERROR: creating subvolume for $host-$group: $!" );

    return 1;
}

sub delete_btrfs_subvolume {
    my ( $taskid, $host, $group, $path ) = @_;

    my $btrfs_subvolume_cmd = "$serverconfig{path_btrfs} subvolume delete $path >/dev/null 2>&1";
    $btrfs_subvolume_cmd    = "echo $btrfs_subvolume_cmd" if $serverconfig{dryrun};

    logit( $taskid, $host, $group, "Delete btrfs subvolume: $btrfs_subvolume_cmd" );
    system($btrfs_subvolume_cmd) and logit( $taskid, $host, $group, "ERROR: deleting subvolume for $host-$group: $!" );

    return 1;
}

sub create_btrfs_snapshot {
    my ( $taskid, $host, $group, $bkptimestamp ) = @_;

    return unless ( $hosts{"$host-$group"}->{hostconfig}->{BKP_STORE_MODUS} eq 'snapshots' );

    my $btrfs_cmd             = $serverconfig{path_btrfs};
    my $btrfs_snapshot_source = targetpath( $host, $group ) . "/current";
    my $btrfs_snapshot_dest   = targetpath( $host, $group ) . "/" . $bkptimestamp;

    my $touch_current_cmd    = "touch $btrfs_snapshot_source >/dev/null 2>&1";
    $touch_current_cmd       = "echo $touch_current_cmd" if $serverconfig{dryrun};
    logit( $taskid, $host, $group, "Touch current folder for host $host group $group" );
    system($touch_current_cmd) and logit( $taskid, $host, $group, "ERROR: touching current folder for $host-$group: $!" );

    my $btrfs_snapshot_cmd    = "$btrfs_cmd subvolume snapshot -r $btrfs_snapshot_source $btrfs_snapshot_dest >/dev/null 2>&1";
    $btrfs_snapshot_cmd       = "echo $btrfs_snapshot_cmd" if $serverconfig{dryrun};
    logit( $taskid, $host, $group, "Create btrfs snapshot for host $host group $group using $btrfs_snapshot_cmd" );
    system($btrfs_snapshot_cmd) and logit( $taskid, $host, $group, "ERROR: creating snapshot for $host-$group: $!" );

    return 1;
}

#################################
# Wipe old backups
#
sub wipe {
    my ($taskid, $host, $group, $force) = @_;

    # make sure we are on the correct backup server
    return unless bkp_to_current_server($taskid, $host, $group);

    # make sure wipe is enabled
    return unless $hosts{"$host-$group"}->{hostconfig}->{WIPE_ENABLED};

    # stop if trying to do bulk wipe if it's not allowed
    return unless ( ($group_arg && $host_arg) || $hosts{"$host-$group"}->{hostconfig}->{WIPE_BULK_ALLOW} );


    # check for still running backups
    return unless check_lockfile( $taskid, $host, $group );

    logit( $taskid, $host, $group, "Wipe host $host group $group" );

    my @backup_folders = get_backup_folders( $host, $group );

    # count existing backups
    my $bkpkeep = 0;
    foreach my $type (qw( DAILY WEEKLY MONTHLY )) {
        $bkpkeep += $hosts{"$host-$group"}->{hostconfig}->{"WIPE_KEEP_$type"};
    }
    my $bkpcount = $#backup_folders + 1;

    # get list of folders to wipe
    my %stack    = list_folders_to_wipe( $host, $group, @backup_folders );
    my @wipedirs = @{ $stack{wipe} };

    logit( $taskid, $host, $group, "Wipe existing: $bkpcount, to wipe: " . ( $#{$stack{wipe}} +1 ) .", keeping: $bkpkeep for host $host group $group" );

    # generate wipe report with content of stacks
    if ( $serverconfig{debuglevel} >= 2 ) {
        my $wipe_report = "Wipe report\n";
        foreach my $type ( sort keys %stack ) {
            $wipe_report .= "\t" . uc($type) . " : " . ( $#{$stack{$type}} + 1 ) . "\n";
            foreach my $folder ( @{$stack{$type}} ) {
                $wipe_report .= "\t$folder\n";
            }
        }
        logit( $taskid, $host, $group, $wipe_report );
    }

    # don't automatically wipe too many backups
    if ( $force ) {
        logit( $taskid, $host, $group, "Wipe WARNING: forced to wipe, namely " . ( $#{$stack{wipe}} + 1 ) . "." );
    } elsif ( $#{$stack{wipe}} >= $serverconfig{auto_wipe_limit} ) {
        logit( $taskid, $host, $group, "Wipe WARNING: too many folders to wipe, namely " . ( $#{$stack{wipe}} + 1 ) . ". Wipe manually or use --force." );
        return ();
    }

    # make sure list contains at least one folder
    if ( !@wipedirs ) {
        logit( $taskid, $host, $group, "Wipe no folder to wipe for host $host group $group" );
        return 1;
    }

    # remove subvolumes or folders
    if ( $hosts{"$host-$group"}->{hostconfig}->{BKP_STORE_MODUS} eq 'snapshots' ) {
        # Limit snapshot wipe to the last x days -> performance issues
        if ( ( $#{$stack{wipe}} + 1 ) > $serverconfig{snapshot_wipe_limit} ) {
           logit( $taskid, $host, $group, "Wipe WARNING: snapshot limit reached, wipe only oldest $serverconfig{snapshot_wipe_limit} snapshots." );
        }
        @wipedirs = splice(@wipedirs,0,$serverconfig{snapshot_wipe_limit});

        delete_btrfs_subvolume( $taskid, $host, $group, join(' ', @wipedirs) );
        delete_logfiles( $taskid, $host, $group, @wipedirs );
    } else {
        my $rmcmd = 'rm -Rf';
        $rmcmd = "echo $rmcmd" if $serverconfig{dryrun};
        foreach my $dir (@wipedirs) {
            logit( $taskid, $host, $group, "Wipe $rmcmd $dir for host $host group $group" );
            system("$rmcmd $dir") and logit( $taskid, $host, $group, "ERROR: removing folder $dir for $host-$group: $!" );
        }
    }

    logit( $taskid, $host, $group, "Wipe successful of host $host group $group" );

    return 1;
}

sub delete_logfiles {
    my ($taskid, $host, $group, @wipedirs) = @_;

        foreach my $dir (@wipedirs) {
            my ($logdate) = $dir =~ /.*\/(\d{4}\.\d{2}\.\d{2})/;
            $logdate =~ s/\./\-/g;
            my $today = `$serverconfig{path_date} +"%Y-%m-%d"`;
            chomp $today;
            unless ( $logdate eq $today ) {
                my $logfolder  = "$serverconfig{path_logs}/${host}_${group}";
                my $logfile    = "$logfolder/$logdate.log";
                my $rmcmd = 'rm -f';
                $rmcmd = "echo $rmcmd" if $serverconfig{dryrun};

                logit( $taskid, $host, $group, "Delete logfile $logfile" );
                system("$rmcmd $logfile") and logit( $taskid, $host, $group, "ERROR: deleting logfile $logfile: $!" );
            }
        }
}

#################################
# last_bkp_file
#
sub last_bkp_file {
    my ($host, $group) = @_;

    my $hostconfig  = $hosts{"$host-$group"}->{hostconfig};
    my $bkpdir      = "$hostconfig->{BKP_TARGET_PATH}/$hostconfig->{BKP_PREFIX}/$host";
    my $lastBkpFile = "$bkpdir/$hostconfig->{BKP_LASTBKP_FILE}";

    return $lastBkpFile;
}

sub check_last_bkp {
    my ($taskid, $host, $group) = @_;

    my $lastbkp = 'nolastbkp';
    my $lastBkpFile = last_bkp_file($host, $group);

    if ( -e $lastBkpFile ) {
        $lastbkp = `cat $lastBkpFile`;
        chomp($lastbkp);
    }

    logit( $taskid, $host, $group, "Found lastbkp = $lastbkp" );

    return $lastbkp;
}

sub create_last_bkp_file {
    my ($taskid, $host, $group, $bkptimestamp) = @_;

    my $lastBkpFile = last_bkp_file($host, $group);
    system("echo \"$bkptimestamp\" > $lastBkpFile") unless $serverconfig{dryrun};
    logit( $taskid, $host, $group, "Write lastBkpFile: $bkptimestamp \-\> $lastBkpFile" );

    return 1;
}

#################################
# Helper subroutines
#
sub create_timeid {
    my ($host, $group, $taskid) = @_;
    my ($s, $usec) = gettimeofday;
    my $timeid      = `$serverconfig{path_date} +"%Y%m%d%H%M%S"` . $usec;
    $timeid =~ s/\n//g;
    $host  ||= "SERVER";
    $group ||= "GLOBAL";
    $taskid ||= $timeid;
    logit( $taskid, $host, $group, "Created TimeID: $timeid" );

    return $timeid;
}

sub eval_bkptimestamp {
    my ($host, $group) = @_;

    my $bkptimestamp = eval( $hosts{"$host-$group"}->{hostconfig}->{BKP_FOLDER} );
    chomp($bkptimestamp);

    return $bkptimestamp;
}

sub finish_backupjob {
    my ($bkpjob) = @_;
    my $taskid       = $bkpjob->{'taskid'};
    my $jobid        = $bkpjob->{'jobid'};
    my $host         = $bkpjob->{'host'};
    my $group        = $bkpjob->{'group'};
    my $bkptimestamp = $bkpjob->{'bkptimestamp'};
    my $lastbkp      = $bkpjob->{'lastbkp'};
    my $dosnapshot   = $bkpjob->{'dosnapshot'};

    bangstat_set_jobstatus( $taskid, $jobid, $host, $group, $lastbkp, '1' );

    if ( $dosnapshot ) {
        create_btrfs_snapshot( $taskid, $host, $group, $bkptimestamp );
        create_last_bkp_file( $taskid, $host, $group, $bkptimestamp );

        my %RecentBackups = bangstat_recentbackups($host);
        hobbit_report( $taskid, $host, $group, %RecentBackups );
        mail_report( $taskid, $host, $group, %RecentBackups ) if $serverconfig{report_to};
        logit( $taskid, $host, $group, "Backup successful for host $host group $group!" );
    }

    return 1;
}

sub bkp_to_current_server {
    my ($taskid, $host, $group) = @_;

    # make sure backup's target host matches local hostname
    my $bkp_target_host = $hosts{"$host-$group"}->{hostconfig}->{BKP_TARGET_HOST};
    if ( $bkp_target_host ne $servername && $bkp_target_host ne '*' ) {
        logit( $taskid, $host, $group, "Skipping host $host group $group for server $bkp_target_host instead of $servername" ) if $serverconfig{debug};
        return 0;
    }

    return 1;
}

#################################
# Command line arguments
#
sub parse_command_options {

    GetOptions(
        "help"             => sub { usage('') },
        "v|version"        => sub { usage("Current version number: $version") },
        "d|debug"          => \$debug_arg,
        "n|dry-run"        => \$dryrun_arg,
        "g|group=s"        => \$group_arg,
        "h|host=s"         => \$host_arg,
        "p|prefix=s"       => \$prefix_arg,
        "t|threads=i"      => \$nthreads_arg,
        "w|wipe"           => \$wipe,
        "cleanup"          => \$cleanup,
        "finallysnapshots" => \$finallysnapshots,
        "force"            => \$force,
        "missingonly"      => \$missingonly,
        "hobbit"           => \$hobbitonly,
    ) or usage("Invalid commmand line options.");
    usage("You must provide some arguments")    unless ( $host_arg || $group_arg );
    usage("Number of threads must be positive") if ( $nthreads_arg && $nthreads_arg <= 0 );

    $debug_arg = 1 if $dryrun_arg;

    return 1;
}

sub cli_args_override_global_config {

    $serverconfig{debug}      = $debug_arg      if $debug_arg;
    $serverconfig{debuglevel} = $debuglevel_arg if $debuglevel_arg;
    $serverconfig{dryrun}     = $dryrun_arg     if $dryrun_arg;

    return 1;
}

sub usage {
    my ($message) = @_;

    if ( defined $message && length $message ) {
        $message .= "\n"
            unless $message =~ /\n$/;
    }

    my $command = $0;
    $command    =~ s#^.*/##;

    print <<"EOF";
        $message
        Usage Examples:

        $command -h <hostname> -g <group>   # back up given host and group
        $command -h <hostname>              # back up all groups of given host
        $command -g <group>                 # back up all hosts of given group
        $command -v                         # show version number
        $command --help                     # show this help message

        Optional Arguments:

        -n                 # dry-run without making changes
        -t <nr>            # number of threads, default: 1
        -p <path>          # override path to folder containing etc/
        -w                 # wipe the backup
        -w --force         # forcing wipe the backup (override auto_wipe_limit)
        --cleanup          # cleanup threaded jobs
        --finallysnapshots # make snapshots after the hole backup stuff
        --missingonly      # backup only hosts that were not backed up recently
        --hobbit           # send only hobbit report
        -d                 # show debugging messages

EOF
    exit 0;
}
