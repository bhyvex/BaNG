#!/usr/bin/env perl
use strict;
use warnings;
use forks;
use Cwd qw( abs_path );
use Date::Parse;
use File::Basename;
use Getopt::Long qw( :config no_auto_abbrev );
use Time::HiRes qw( gettimeofday );
use Thread::Queue;

use lib dirname( abs_path($0) ) . '/lib';
use BaNG::Config;
use BaNG::BackupServer;
use BaNG::Reporting;
use BaNG::TM_rsync;
use BaNG::BTRFS;
use BaNG::Wipe;

my $version = '3.6';
my $cron;
my $force;
my $wipe;
my $initial;
my $xymononly;
my $noreport;
my $missingonly;
my $group_arg;
my $host_arg;
my $prefix_arg;
my $nthreads_arg;
my $verbose_arg;
my $vv_arg;
my $vvv_arg;
my $dryrun_arg;
my @queue;
my %finishable_bkpjobs;
my $taskid;
my $taskmeta;
my $startstamp;
my $endstamp;

#################################
# Main
#
parse_command_options();
get_serverconfig($prefix_arg);
cli_args_override_global_config();

$cron = $ENV{'BaNG_Cron'} || "0";
print "Run as Cron: $cron\n" if $serverconfig{verbose};

$taskid = create_timeid( $host_arg, $group_arg );

bangstat_set_taskmeta( $taskid, $host_arg, $group_arg, $cron, $taskmeta) unless ( $wipe || $xymononly );

get_host_config( $host_arg, $group_arg );

foreach my $config ( sort keys %hosts ) {
    if ($wipe) {
        wipe( $hosts{$config}->{hostname}, $hosts{$config}->{group}, $taskid, $force );
    } elsif ($xymononly) {
        my $host          = $hosts{$config}->{hostname};
        my $group         = $hosts{$config}->{group};
        my %RecentBackups = bangstat_recentbackups($host);
        xymon_report( $taskid, $host, $group, %RecentBackups );
    } else {
        queue_backup( $hosts{$config}->{hostname}, $hosts{$config}->{group} );
    }
}

if ( !@queue ) {
    print "Exit because queue is empty.\n" if ( $serverconfig{verbose} && !$wipe );
    exit 0;
}

reorder_queue_by_priority( $host_arg, $group_arg );
run_threads();
foreach my $finishable_bkpjob (sort keys %finishable_bkpjobs) {
    finish_backupjob($finishable_bkpjobs{$finishable_bkpjob});
}
logit( $taskid, $host_arg, $group_arg, "Task $taskid finished!" );

exit 0;

#################################
# Queuing
#
sub reorder_queue_by_priority {
    my ( $host, $group ) = @_;
    my @prio_queue;
    my @prio_queue_sorted;
    $host  ||= 'SERVER';
    $group ||= 'GLOBAL';

    logit( $taskid, $host, $group, "reorder queue by priority!" );

    # add priority information to all queued backup jobs
    foreach my $bkpjob (@queue) {
        my $host  = $bkpjob->{host};
        my $group = $bkpjob->{group};
        my $path  = $bkpjob->{path};
        $path =~ s/'//g;

        my $prio = $hosts{"$host-$group"}->{hostconfig}->{BKP_PRIORITY}->{"$path"} || 0;
        $bkpjob->{priority} = $prio;
        print "$path set priority to $prio\n" if $serverconfig{verbose};
        push( @prio_queue, $bkpjob );
    }

    # reorder queue by priority
    print "Final queue order: \n" if $serverconfig{verbose};
    foreach my $bkpjob ( sort { $a->{priority} <=> $b->{priority} } @queue ) {
        print "$bkpjob->{priority} $bkpjob->{path} $bkpjob->{dosnapshot}\n" if $serverconfig{verbose};
        push( @prio_queue_sorted, $bkpjob );
    }

    if ( $#queue == $#prio_queue_sorted ) {
        @queue = @prio_queue_sorted;
    } else {
        logit( $taskid, $host, $group, "ERROR: reorder_queue_by_priority queue lengths don't match!" );
    }

    return 1;
}

sub queue_backup {
    my ( $host, $group ) = @_;
    my $jobid;

    logit( $taskid, $host, $group, "Queueing backup for host $host group $group" );

    # make sure we are on the correct backup server
    return unless bkp_to_current_server( $host, $group, $taskid );

    # make sure BKP_SOURCE_FOLDER is set
    unless ( $hosts{"$host-$group"}->{hostconfig}->{BKP_SOURCE_FOLDER} ) {
        logit( $taskid, $host, $group, "BKP_SOURCE_FOLDER not defined for host $host group $group" );
        return;
    };

    # make sure backup is enabled
    return unless $hosts{"$host-$group"}->{hostconfig}->{BKP_ENABLED};

    # stop if trying to do bulk backup if it's not allowed
    return unless ( ( $group_arg && $host_arg ) || $hosts{"$host-$group"}->{hostconfig}->{BKP_BULK_ALLOW} );

    # check for existing target_path folder
    logit( $taskid, $host, $group, "Check for existing target_path for host $host group $group" );
    my $check_target_code = check_target_exists( $host, $group, $taskid );

    if ( $check_target_code == 0 ) {
        if ( $initial ) {
            my ($return_code, $return_msg) = create_target($host, $group, $taskid );
            logit( $taskid, $host, $group, "$return_msg for host $host group $group" );
        } else {
            logit( $taskid, $host, $group, "Skipping because target_path (" . targetpath($host, $group ) .") does not exist for host $host group $group" );
            print "Skipping backup of $host because target_path (" . targetpath($host, $group ) .") does not exist!\n";
            print "use --initial for the first backup run, otherwise check availability of mount!\n";
            return 1;
        }
    }

    my @backup_folders = reverse(get_backup_folders( $host, $group ));

    #####################
    # MIGRATION "lastdst"
    if ( -f targetpath($host, $group ) . "/lastdst") {
        logit( $taskid, $host, $group, "Found depricated lastdst file for host $host group $group" );
        if ( $hosts{"$host-$group"}->{hostconfig}->{BKP_STORE_MODUS} eq "links" ) {
            if ( (!-d targetpath($host, $group ) . "/current") && ($#backup_folders >= 0)) {
                my ($last_folder) = $backup_folders[0] =~ /([0-9._]*)$/;
                create_link_current($host, $group, $last_folder);
            }
        }
        unlink(targetpath($host, $group ) . "/lastdst") unless $serverconfig{dryrun};
        logit( $taskid, $host, $group, "Delete depricated lastdst file for host $host group $group" );
    }
    # MIGRATION "lastdst"
    #####################

    # if missingonly, don't queue host if we had a backup within the last 20 hours
    if ( $missingonly && $backup_folders[0] =~ qr{ .*/(?<date>[^_]*) _ (?<HH>\d\d) (?<MM>\d\d) (?<SS>\d\d)$ }x ) {
        my $lastbkpepoch = str2time("$+{date} $+{HH}:$+{MM}:$+{SS}");
        if ( ( time - $lastbkpepoch ) < 20 * 3600 ) {
            logit( $taskid, $host, $group, "Skipping because recent backup found for host $host group $group" );
            return 1;
        }
    }

    # make sure host is online
    my ( $conn_status, $conn_msg ) = check_client_connection( $host, $hosts{"$host-$group"}->{hostconfig}->{BKP_GWHOST} );
    logit( $taskid, $host, $group, "check_client_connection: $conn_status, $conn_msg" );

    if ( !$conn_status ) {
        $startstamp = time();
        $endstamp   = $startstamp;
        $jobid = create_timeid( $host, $group );
        logit( $taskid, $host, $group, "Error: host $host is offline" );
        bangstat_start_backupjob( $taskid, $jobid, $host, $group, $startstamp, $endstamp, $hosts{"$host-$group"}->{hostconfig}->{BKP_SOURCE_FOLDER},
                                  $hosts{"$host-$group"}->{hostconfig}->{BKP_SOURCE_FOLDER}, targetpath( $host, $group ), '0', '-1', '' ) unless $noreport;
        return 1;
    }

    # make sure rsh/ssh connection works
    my ( $rshell_status, $rshell_msg ) = check_client_rshell_connection( $host, $hosts{"$host-$group"}->{hostconfig}->{BKP_RSYNC_RSHELL}, $hosts{"$host-$group"}->{hostconfig}->{BKP_GWHOST} );
    logit( $taskid, $host, $group, "check_client_rshell_connection: $rshell_status, $rshell_msg" );

    if ( !$rshell_status ) {
        $startstamp = time();
        $endstamp   = $startstamp;
        $jobid = create_timeid( $host, $group );
        logit( $taskid, $host, $group, "Error: ". $hosts{"$host-$group"}->{hostconfig}->{BKP_RSYNC_RSHELL} ." on host $host not working" );
        bangstat_start_backupjob( $taskid, $jobid, $host, $group, $startstamp, $endstamp, $hosts{"$host-$group"}->{hostconfig}->{BKP_SOURCE_FOLDER},
                                  $hosts{"$host-$group"}->{hostconfig}->{BKP_SOURCE_FOLDER}, targetpath( $host, $group ), '0', '-2', '' ) unless $noreport;
        return 1;
    }

    if ( !-e ($serverconfig{path_rsync} || "") ) {
        $startstamp = time();
        $endstamp   = $startstamp;
        $jobid = create_timeid( $host, $group );
        logit( $taskid, $host, $group, "RSYNC command " . ($serverconfig{path_rsync} || "") . " not found!" );
        bangstat_start_backupjob( $taskid, $jobid, $host, $group, $startstamp, $endstamp, $hosts{"$host-$group"}->{hostconfig}->{BKP_SOURCE_FOLDER},
                                  $hosts{"$host-$group"}->{hostconfig}->{BKP_SOURCE_FOLDER}, targetpath( $host, $group ), '0', '-5', '' ) unless $noreport;
        return 1;
    }

    my $bkptimestamp = eval_bkptimestamp( $host, $group );

    # get list of source folders to back up
    my (@src_folders) = split( / /, $hosts{"$host-$group"}->{hostconfig}->{BKP_SOURCE_FOLDER} );
    logit( $taskid, $host, $group, 'Number of source folders: ' . ( $#src_folders + 1 ) . " ( @src_folders )" );
    logit( $taskid, $host, $group, 'Status source folder threading: ' . $hosts{"$host-$group"}->{hostconfig}->{BKP_THREAD_SRCFOLDERS} );

    if (( $hosts{"$host-$group"}->{hostconfig}->{BKP_THREAD_SRCFOLDERS} ) || ( $#src_folders  == 0 )) {
        # optionally queue each subfolder of the source folders while only 1 srcfolder defined
        if ( $hosts{"$host-$group"}->{hostconfig}->{BKP_THREAD_SUBFOLDERS} ) {

            my $dosnapshot = 0;
            my $numFolder  = @src_folders;

            foreach my $folder (@src_folders) {
                $jobid = create_timeid( $host, $group );

                $numFolder--;
                if ( $numFolder == 0 ) {
                    $dosnapshot = 1;
                }
                queue_remote_subfolders( $jobid, $host, $group, $bkptimestamp, $dosnapshot, $folder );
            }

        } else {

            my $dosnapshot = 0;
            my $numFolder  = @src_folders;

            $jobid = create_timeid( $host, $group );

            foreach my $folder (@src_folders) {

                $numFolder--;
                if ( $numFolder == 0 ) {
                    $dosnapshot = 1;
                }

                my $bkpjob = {
                    jobid        => $jobid,
                    host         => $host,
                    group        => $group,
                    path         => "$folder",
                    srcfolder    => "@src_folders",
                    bkptimestamp => $bkptimestamp,
                    dosnapshot   => $dosnapshot,
                };
                push( @queue, $bkpjob );
            }

            my $bkpjob = {
                jobid        => $jobid,
                host         => $host,
                group        => $group,
                bkptimestamp => $bkptimestamp,
                dosnapshot   => $dosnapshot,
                rsync_err    => 0,
                has_failed   => 0,
            };
        }

    } else {
        # queue list of source folders as a whole
        $jobid = create_timeid( $host, $group );
        my $bkpjob = {
            jobid        => $jobid,
            host         => $host,
            group        => $group,
            path         => "@src_folders",
            srcfolder    => "@src_folders",
            bkptimestamp => $bkptimestamp,
            dosnapshot   => 1,
            rsync_err    => 0,
            has_failed   => 0,
        };
        push( @queue, $bkpjob );
    }

    logit( $taskid, $host, $group, "End of queueing backup of host $host group $group" );

    return 1;
}

sub queue_remote_subfolders {
    my ( $jobid, $host, $group, $bkptimestamp, $dosnapshot, $srcfolder ) = @_;

    $srcfolder =~ s/://;
    my $remoteshell      = $hosts{"$host-$group"}->{hostconfig}->{BKP_RSYNC_RSHELL};
    my @remotesubfolders = `$remoteshell $host find $srcfolder -xdev -type d -mindepth 1 -maxdepth 1 -not -empty | sort`;

    # if @remotesubfolders empty (rsh troubles?) then use the $srcfolder
    if ( $#remotesubfolders == -1 ) {
        push( @remotesubfolders, $srcfolder );
        logit( $taskid, $host, $group, "ERROR: eval subfolders failed, use now with:\n @remotesubfolders" );
    } else {
        logit( $taskid, $host, $group, "eval subfolders:\n @remotesubfolders" );
    }

    my $exclsubfolderfile = create_generic_exclude_file($host, $group, $jobid);

    open(my $fhExcludeFile, '>>', $exclsubfolderfile) unless $serverconfig{dryrun};

    foreach my $remotesubfolder (@remotesubfolders) {
        chomp $remotesubfolder;
        $remotesubfolder =~ s| |\\ |g;
        $remotesubfolder =~ s|\&|\\&|g;
        $remotesubfolder =~ s|\(|\\\(|g;
        $remotesubfolder =~ s|\)|\\\)|g;

        my $bkpjob = {
            jobid        => $jobid,
            host         => $host,
            group        => $group,
            path         => ":'${remotesubfolder}'",
            bkptimestamp => $bkptimestamp,
            srcfolder    => ":$srcfolder",
            dosnapshot   => 0,
        };
        push( @queue, $bkpjob );

        $remotesubfolder =~ s|^/||g;
        print $fhExcludeFile "- $remotesubfolder/\n" unless $serverconfig{dryrun};
        print "- $remotesubfolder/\n" if $serverconfig{verbose};
    }
    close $fhExcludeFile unless $serverconfig{dryrun};

    # add bkp job for files only
    my $bkpjob = {
        jobid          => $jobid,
        host           => $host,
        group          => $group,
        path           => ":'${srcfolder}'",
        bkptimestamp   => $bkptimestamp,
        srcfolder      => ":$srcfolder",
        dosnapshot     => $dosnapshot,
        exclsubfolders => 1,
    };
    push( @queue, $bkpjob );

    return 1;
}

#################################
# Threading
#
sub run_threads {

    # define number of threads
    my $nthreads;
    if ($nthreads_arg) {

        # If nthreads was defined by cli argument, use it
        $nthreads = $nthreads_arg;
        print "Using nthreads = $nthreads from command line argument\n" if $serverconfig{verbose};
    } elsif ( $host_arg && $group_arg ) {

        # If no nthreads was given, and we back up a single host and group, get nthreads from its config
        $nthreads = $hosts{"$host_arg-$group_arg"}->{hostconfig}->{BKP_THREADS_DEFAULT};
        print "Using nthreads = $nthreads from $host_arg-$group_arg config file\n" if $serverconfig{verbose};
    } else {
        $nthreads = 1;
    }
    my $Q = Thread::Queue->new;
    my @threads = map { threads->create( \&thread_work, $Q ) } ( 1 .. $nthreads );
    $Q->enqueue($_) for @queue;
    $Q->enqueue( (undef) x $nthreads );

    foreach my $thread (@threads) {
        my (@finishable_bkpjobs_in_thread) = $thread->join;

        # Merge bkpjobs returned by this thread with already known jobs
        foreach my $bkpjob (@finishable_bkpjobs_in_thread) {
            if ( exists $finishable_bkpjobs{$bkpjob->{jobid}} ) {
                $finishable_bkpjobs{$bkpjob->{jobid}}->{has_failed} = 1 if $bkpjob->{has_failed};
                $finishable_bkpjobs{$bkpjob->{jobid}}->{dosnapshot} = 1 if $bkpjob->{dosnapshot};
            } else {
                $finishable_bkpjobs{$bkpjob->{jobid}} = $bkpjob;
            }
            # Push unique rsync errors to array
            unless( grep { $_ == $bkpjob->{rsync_err} } @{ $finishable_bkpjobs{$bkpjob->{jobid}}->{rsync_errs} } ) {
                push( @{ $finishable_bkpjobs{$bkpjob->{jobid}}->{rsync_errs} }, $bkpjob->{rsync_err} );
            }
        }
    }

    return 1;
}

sub thread_work {
    my ($Q) = @_;
    my @finishable_bkpjobs_in_thread;

    while ( my $bkpjob = $Q->dequeue ) {
        my $tid            = threads->tid;
        my $jobid          = $bkpjob->{jobid};
        my $host           = $bkpjob->{host};
        my $group          = $bkpjob->{group};
        my $path           = $bkpjob->{path};
        my $bkptimestamp   = $bkpjob->{bkptimestamp};
        my $srcfolder      = $bkpjob->{srcfolder};
        my $dosnapshot     = $bkpjob->{'dosnapshot'};
        my $exclsubfolders = $bkpjob->{'exclsubfolders'} || 0;

        my $random_integer = int( rand(10) ) + 1;
        $random_integer = 0 if ( $dryrun_arg || not $hosts{"$host-$group"}->{hostconfig}->{BKP_THREAD_SUBFOLDERS} );

        return unless create_lockfile( $taskid, $host, $group, $path );
        writeto_lockfile( $taskid, $host, $group, $path, "cron", $cron);
        logit( $taskid, $host, $group, "Thread $tid sleep $random_integer sec. for $host-$group ($path)" );
        sleep($random_integer);
        logit( $taskid, $host, $group, "Thread $tid working on $host-$group ($path)" );
        my $rsync_err = execute_rsync( $taskid, $jobid, $noreport, $host, $group, $bkptimestamp, $path, $srcfolder ,$exclsubfolders );
        logit( $taskid, $host, $group, "Thread $tid finished with $host-$group ($path) ErrCode: $rsync_err" );
        my $bkpjob = {
            jobid        => $jobid,
            host         => $host,
            group        => $group,
            bkptimestamp => $bkptimestamp,
            dosnapshot   => $dosnapshot,
            rsync_err    => $rsync_err,
            has_failed   => check_rsync_status( $rsync_err ),
        };
        push(@finishable_bkpjobs_in_thread, $bkpjob);
        remove_lockfile( $taskid, $host, $group, $path );
    }

    return (@finishable_bkpjobs_in_thread);
}

#################################
# Helper subroutines
#
sub create_timeid {
    my ( $host, $group ) = @_;

    my ( $s, $usec ) = gettimeofday;
    my $timeid = `$serverconfig{path_date} +"%Y%m%d%H%M%S"` . $usec;
    $timeid =~ s/\n//g;
    $host   ||= "SERVER";
    $group  ||= "GLOBAL";
    $taskid ||= $timeid;
    logit( $taskid, $host, $group, "Created TimeID: $timeid" );

    return $timeid;
}

sub create_link_current {
    my ( $host, $group, $bkptimestamp ) = @_;

    my $link_source  = targetpath( $host, $group ) . '/' . $bkptimestamp;
    my $link_dest    = targetpath( $host, $group ) . '/current';
    my $ln_cmd       = "/bin/ln -s";

    if ( -l $link_dest ){
        unlink $link_dest unless $serverconfig{dryrun};
        logit( $taskid, $host, $group, "Delete existing current symlink for host $host group $group" );
    }

    my $link_cmd = "$ln_cmd $link_source $link_dest >/dev/null 2>&1";
    $link_cmd = "echo $link_cmd" if $serverconfig{dryrun};
    logit( $taskid, $host, $group, "Create symlink for host $host group $group using $link_cmd" );
    system($link_cmd) and logit( $taskid, $host, $group, "ERROR: creating symlink for $host-$group: $!" );

    return 1;
}

sub eval_bkptimestamp {
    my ( $host, $group ) = @_;

    my $bkptimestamp = eval( $hosts{"$host-$group"}->{hostconfig}->{BKP_FOLDER} );
    chomp($bkptimestamp);

    return $bkptimestamp;
}

sub rename_failed_backup {
    my ( $host, $group, $bkptimestamp ) = @_;

    my $failed_source  = targetpath( $host, $group ) . '/' . $bkptimestamp;
    my $failed_dest    = targetpath( $host, $group ) . '/' . $bkptimestamp . "_failed";
    my $mv_cmd       = "/bin/mv";

    if ( -e $failed_source ) {
        my $rename_cmd = "$mv_cmd $failed_source $failed_dest >/dev/null 2>&1";
        $rename_cmd = "echo $rename_cmd" if $serverconfig{dryrun};
        logit( $taskid, $host, $group, "Rename failed folder for host $host group $group using $rename_cmd" );
        system($rename_cmd) and logit( $taskid, $host, $group, "ERROR: renaming failed folder for $host-$group: $!" );
    } else {
        logit( $taskid, $host, $group, "ERROR: $failed_source not exists, skip renaming failed folder for host $host group $group" );
    }

    return 1;
}

sub finish_backupjob {
    my ($bkpjob)     = @_;
    my $jobid        = $bkpjob->{'jobid'};
    my $host         = $bkpjob->{'host'};
    my $group        = $bkpjob->{'group'};
    my $bkptimestamp = $bkpjob->{'bkptimestamp'};
    my $dosnapshot   = $bkpjob->{'dosnapshot'};
    my $has_failed   = $bkpjob->{'has_failed'};
    my $rsync_err    = join(', ', sort @{ $bkpjob->{'rsync_errs'} });
    my @rsync_pass   = @{ $serverconfig{'rsync_err_ok'} };

    if (( $hosts{"$host-$group"}->{hostconfig}->{BKP_STORE_MODUS} eq 'snapshots' ) &&  ( $dosnapshot )) {
        my $rsync_target = targetpath( $host, $group );
        create_btrfs_snapshot( $host, $group, $bkptimestamp, $taskid, $rsync_target);
        if ( $has_failed ) {
            logit( $taskid, $host, $group, "rsync in snapshot-mode failed with code $rsync_err for host $host group $group" ) if $serverconfig{verbose};
            rename_failed_backup( $host, $group, $bkptimestamp );
        } else {
            logit( $taskid, $host, $group, "rsync in snapshot-mode successfully finished with (code $rsync_err) for host $host group $group" ) if $serverconfig{verbose};
        }
    }
    if ( $hosts{"$host-$group"}->{hostconfig}->{BKP_STORE_MODUS} eq 'links' ) {
        if ( $has_failed ) {
            logit( $taskid, $host, $group, "rsync in links-mode failed with code $rsync_err for host $host group $group" ) if $serverconfig{verbose};
            rename_failed_backup( $host, $group, $bkptimestamp );
        } else {
            logit( $taskid, $host, $group, "rsync in links-mode successfully finished with (code $rsync_err) for host $host group $group" ) if $serverconfig{verbose};
            create_link_current( $host, $group, $bkptimestamp );
        }
    }

    # report finished job to DB, jobstatus => 2
    bangstat_finish_backupjob( $taskid, $jobid, $host, $group, '2' ) unless $noreport;

    my %RecentBackups = bangstat_recentbackups($host);
    unless ($noreport) {
        xymon_report( $taskid, $host, $group, %RecentBackups );
        mail_report( $taskid, $host, $group, %RecentBackups ) if $serverconfig{report_to};
    }
    logit( $taskid, $host, $group, "Backup successful for host $host group $group!" );

    remove_generic_exclude_file($host, $group, $jobid) if $hosts{"$host-$group"}->{hostconfig}->{BKP_THREAD_SUBFOLDERS};

    return 1;
}

sub generic_exclude_file {
    my ( $host, $group, $jobid ) = @_;
    my $exclsubfolderfilename = "generated.${host}_${group}_${jobid}";
    my $exclsubfolderfile     = "$serverconfig{path_excludes}/$exclsubfolderfilename";

    return $exclsubfolderfile;
}

sub create_generic_exclude_file {
    my ( $host, $group, $jobid ) = @_;
    my $exclsubfolderfile        = generic_exclude_file( $host, $group, $jobid );

    unless ( $serverconfig{dryrun} ) {
        system("touch \"$exclsubfolderfile\"") and logit( $taskid, $host, $group, "ERROR: could not create generated excludefile $exclsubfolderfile" );
    }
    logit( $taskid, $host, $group, "Create generated exclude file $exclsubfolderfile" );
    return $exclsubfolderfile;
}

sub remove_generic_exclude_file {
    my ( $host, $group, $jobid ) = @_;
    my $exclsubfolderfile        = generic_exclude_file( $host, $group, $jobid );

    if ( -e $exclsubfolderfile ) {
        unlink "$exclsubfolderfile";
    }
    logit( $taskid, $host, $group, "Remove generated exclude file $exclsubfolderfile" );

    return 1;
}

#################################
# Command line arguments
#
sub parse_command_options {

    GetOptions(
        'help'             => sub { usage('') },
        'version'          => sub { usage("Current version number: $version") },
        'v|verbose'        => \$verbose_arg,
        'vv'               => \$vv_arg,
        'vvv'              => \$vvv_arg,
        'n|dry-run'        => \$dryrun_arg,
        'g|group=s'        => \$group_arg,
        'h|host=s'         => \$host_arg,
        'p|prefix=s'       => \$prefix_arg,
        't|threads=i'      => \$nthreads_arg,
        'w|wipe'           => \$wipe,
        'initial'          => \$initial,
        'force'            => \$force,
        'missingonly'      => \$missingonly,
        'label=s'          => \$taskmeta,
        'xymon'            => \$xymononly,
        'noreport'         => \$noreport,
    ) or usage('Invalid commmand line options.');
    usage('You must provide some arguments') unless ( $host_arg || $group_arg );
    usage('Number of threads must be positive') if ( $nthreads_arg && $nthreads_arg <= 0 );

    $verbose_arg = 1 if ( $dryrun_arg || $vv_arg || $vvv_arg );

    return 1;
}

sub cli_args_override_global_config {

    $serverconfig{verbose}      = $verbose_arg if $verbose_arg;
    $serverconfig{dryrun}       = $dryrun_arg  if $dryrun_arg;
    $serverconfig{verboselevel} = 2            if $vv_arg;
    $serverconfig{verboselevel} = 3            if $vvv_arg;

    return 1;
}

sub usage {
    my ($message) = @_;

    if ( defined $message && length $message ) {
        $message .= "\n"
            unless $message =~ /\n$/;
    }

    my $command = $0;
    $command =~ s#^.*/##;

    print <<"EOF";
        $message
        Usage Examples:

        $command -h <host> -g <group> # back up given host and group
        $command -h <host>            # back up all groups of given host
        $command -g <group>           # back up all hosts of given group
        $command --help               # show this help message
        $command --version            # show version number and help

        Optional Arguments:

        -t <nr>            # number of threads, default: 1
        -p <path>          # override path to folder containing etc/
        -w | --wipe        # wipe the backup
        -w --force         # forcing wipe the backup (override auto_wipe_limit)
        --initial          # create nonexisting backup targets
        --missingonly      # backup only hosts that were not backed up recently
        --label <string>   # set a label for this task
        --xymon            # send only xymon report
        --noreport         # do not send any report
        -v | -vv | -vvv    # verbose mode to include debugging messages of level 1-3
        -n                 # dry-run without making changes (implies verbose)

EOF

    exit 0;
}
