#!/usr/bin/env perl
use strict;
use warnings;
use forks;
use Cwd qw( abs_path );
use Date::Parse;
use File::Basename;
use Getopt::Long qw( :config no_auto_abbrev );
use IPC::Open3;
use Time::HiRes qw( gettimeofday );
use Thread::Queue;

use lib dirname( abs_path($0) ) . '/lib';
use BaNG::Hosts;
use BaNG::Common;
use BaNG::Config;
use BaNG::Reporting;
use BaNG::Wipe;

my $version = '3.4';
my $force;
my $wipe;
my $initial;
my $xymononly;
my $noreport;
my $missingonly;
my $group_arg;
my $host_arg;
my $prefix_arg;
my $nthreads_arg;
my $finallysnapshots;
my $verbose_arg;
my $vv_arg;
my $vvv_arg;
my $dryrun_arg;
my @queue;
my @finally_snapshots;
my $taskid;

#################################
# Main
#
parse_command_options();
get_serverconfig($prefix_arg);
cli_args_override_global_config();

$taskid = create_timeid( $host_arg, $group_arg );

get_host_config( $host_arg, $group_arg );

foreach my $config ( sort keys %hosts ) {
    if ($wipe) {
        wipe( $hosts{$config}->{hostname}, $hosts{$config}->{group}, $force );
    } elsif ($xymononly) {
        my $host          = $hosts{$config}->{hostname};
        my $group         = $hosts{$config}->{group};
        my %RecentBackups = bangstat_recentbackups($host);
        xymon_report( $taskid, $host, $group, %RecentBackups );
    } else {
        queue_backup( $hosts{$config}->{hostname}, $hosts{$config}->{group} );
    }
}

if ( !@queue ) {
    print "Exit because queue is empty.\n" if ( $serverconfig{verbose} && !$wipe );
    exit 0;
}

reorder_queue_by_priority( $host_arg, $group_arg );
start_threads();
finish_backupjob($_) foreach @finally_snapshots;

exit 0;

#################################
# Queuing
#
sub reorder_queue_by_priority {
    my ( $host, $group ) = @_;
    my @prio_queue;
    my @prio_queue_sorted;
    $host  ||= 'SERVER';
    $group ||= 'GLOBAL';

    logit( $taskid, $host, $group, "reorder queue by priority!" );

    # add priority information to all queued backup jobs
    foreach my $bkpjob (@queue) {
        my $host  = $bkpjob->{host};
        my $group = $bkpjob->{group};
        my $path  = $bkpjob->{path};
        $path =~ s/'//g;

        my $prio = $hosts{"$host-$group"}->{hostconfig}->{BKP_PRIORITY}->{"$path"} || 0;
        $bkpjob->{priority} = $prio;
        print "$path set priority to $prio\n" if $serverconfig{verbose};
        push( @prio_queue, $bkpjob );
    }

    # reorder queue by priority
    foreach my $bkpjob ( sort { $a->{priority} <=> $b->{priority} } @queue ) {
        print "$bkpjob->{priority} $bkpjob->{path}\n" if $serverconfig{verbose};
        push( @prio_queue_sorted, $bkpjob );
    }

    if ( $#queue == $#prio_queue_sorted ) {
        @queue = @prio_queue_sorted;
    } else {
        logit( $taskid, $host, $group, "ERROR: reorder_queue_by_priority queue lengths don't match!" );
    }

    return 1;
}

sub queue_backup {
    my ( $host, $group ) = @_;
    my $jobid;

    logit( $taskid, $host, $group, "Queueing backup for host $host group $group" );

    # make sure we are on the correct backup server
    return unless bkp_to_current_server( $host, $group );

    # make sure backup is enabled
    return unless $hosts{"$host-$group"}->{hostconfig}->{BKP_ENABLED};

    # stop if trying to do bulk backup if it's not allowed
    return unless ( ( $group_arg && $host_arg ) || $hosts{"$host-$group"}->{hostconfig}->{BKP_BULK_ALLOW} );

    # check for existing target_path folder
    my ($check_rsync_target_code) = check_rsync_target( $host, $group );
    if ( $check_rsync_target_code > 0 && !$initial ) {
        logit( $taskid, $host, $group, "Skipping because target_path (" . targetpath($host, $group ) .") does not exist for host $host group $group" );
        print "Skipping backup of $host because target_path (" . targetpath($host, $group ) .") does not exist!\n";
        print "use --initial for the first backup run, otherwise check availability of mount!\n";
        return 1;
    }

    my @backup_folders = reverse(get_backup_folders( $host, $group ));

    # if missingonly, don't queue host if we had a backup within the last 20 hours
    if ( $missingonly && $backup_folders[0] =~ qr{ .*/(?<date>[^_]*) _ (?<HH>\d\d) (?<MM>\d\d) (?<SS>\d\d)$ }x ) {
        my $lastbkpepoch = str2time("$+{date} $+{HH}:$+{MM}:$+{SS}");
        if ( ( time - $lastbkpepoch ) < 20 * 3600 ) {
            logit( $taskid, $host, $group, "Skipping because recent backup found for host $host group $group" );
            return 1;
        }
    }

    # make sure host is online
    my ( $conn_status, $conn_msg ) = check_client_connection( $host, $hosts{"$host-$group"}->{hostconfig}->{BKP_GWHOST} );
    logit( $taskid, $host, $group, "check_client_connection: $conn_status, $conn_msg" );
    if ( !$conn_status ) {
        my $startstamp = time();
        my $endstamp   = $startstamp;
        $jobid = create_timeid( $host, $group );
        logit( $taskid, $host, $group, "Error: host $host is offline" );
        bangstat_start_backupjob( $taskid, $jobid, $host, $group, $startstamp, $endstamp, $hosts{"$host-$group"}->{hostconfig}->{BKP_SOURCE_FOLDER}, $hosts{"$host-$group"}->{hostconfig}->{BKP_SOURCE_FOLDER}, targetpath( $host, $group ), $lastbkp, '0', '-1', '' ) unless $noreport;
        return 1;
    }

    my $bkptimestamp = eval_bkptimestamp( $host, $group );

    # get list of source folders to back up
    my (@src_folders) = split( / /, $hosts{"$host-$group"}->{hostconfig}->{BKP_SOURCE_FOLDER} );
    logit( $taskid, $host, $group, 'Number of source folders: ' . ( $#src_folders + 1 ) . " ( @src_folders )" );
    logit( $taskid, $host, $group, 'Status source folder threading: ' . $hosts{"$host-$group"}->{hostconfig}->{BKP_THREAD_SRCFOLDERS} );

    if (( $hosts{"$host-$group"}->{hostconfig}->{BKP_THREAD_SRCFOLDERS} ) || ( $#src_folders  == 0 )) {
        # optionally queue each subfolder of the source folders while only 1 srcfolder defined
        if ( $hosts{"$host-$group"}->{hostconfig}->{BKP_THREAD_SUBFOLDERS} ) {

            my $dosnapshot = 0;
            my $numFolder  = @src_folders;

            foreach my $folder (@src_folders) {
                $jobid = create_timeid( $host, $group );

                $numFolder--;
                if ( $numFolder == 0 ) {
                    $dosnapshot = 1;
                }
                queue_remote_subfolders( $jobid, $host, $group, $lastbkp, $bkptimestamp, $dosnapshot, $folder );
            }

        } else {

            my $dosnapshot = 0;
            my $numFolder  = @src_folders;

            $jobid = create_timeid( $host, $group );

            foreach my $folder (@src_folders) {

                $numFolder--;
                if ( $numFolder == 0 ) {
                    $dosnapshot = 1;
                }

                my $bkpjob = {
                    jobid        => $jobid,
                    host         => $host,
                    group        => $group,
                    path         => "$folder",
                    srcfolder    => "@src_folders",
                    lastbkp      => $lastbkp,
                    bkptimestamp => $bkptimestamp,
                    dosnapshot   => $dosnapshot,
                };
                push( @queue, $bkpjob );
            }

            my $bkpjob = {
                jobid        => $jobid,
                host         => $host,
                group        => $group,
                lastbkp      => $lastbkp,
                bkptimestamp => $bkptimestamp,
                dosnapshot   => $dosnapshot,
            };
            push( @finally_snapshots, $bkpjob ) if $finallysnapshots;
        }

    } else {
        # queue list of source folders as a whole
        $jobid = create_timeid( $host, $group );
        my $bkpjob = {
            jobid        => $jobid,
            host         => $host,
            group        => $group,
            path         => "@src_folders",
            srcfolder    => "@src_folders",
            lastbkp      => $lastbkp,
            bkptimestamp => $bkptimestamp,
            dosnapshot   => 1,
        };
        push( @queue, $bkpjob );
        push( @finally_snapshots, $bkpjob ) if $finallysnapshots;
    }

    logit( $taskid, $host, $group, "End of queueing backup of host $host group $group" );

    return 1;
}

sub queue_remote_subfolders {
    my ( $jobid, $host, $group, $lastbkp, $bkptimestamp, $dosnapshot, $srcfolder ) = @_;

    $srcfolder =~ s/://;
    my $remoteshell      = $hosts{"$host-$group"}->{hostconfig}->{BKP_RSYNC_RSHELL};
    my @remotesubfolders = `$remoteshell $host find $srcfolder -xdev -type d -mindepth 1 -maxdepth 1 | sort`;

    # if @remotesubfolders empty (rsh troubles?) then use the $srcfolder
    if ( $#remotesubfolders == -1 ) {
        push( @remotesubfolders, $srcfolder );
        logit( $taskid, $host, $group, "ERROR: eval subfolders failed, use now with:\n @remotesubfolders" );
    } else {
        logit( $taskid, $host, $group, "eval subfolders:\n @remotesubfolders" );
    }

    my $exclsubfolderfile = create_generic_exclude_file($host, $group, $jobid);

    open(my $fhExcludeFile, '>>', $exclsubfolderfile) unless $serverconfig{dryrun};

    foreach my $remotesubfolder (@remotesubfolders) {
        chomp $remotesubfolder;
        $remotesubfolder =~ s| |\\ |g;
        $remotesubfolder =~ s|\(|\\\(|g;
        $remotesubfolder =~ s|\)|\\\)|g;

        my $bkpjob = {
            jobid        => $jobid,
            host         => $host,
            group        => $group,
            path         => ":'${remotesubfolder}'",
            lastbkp      => $lastbkp,
            bkptimestamp => $bkptimestamp,
            srcfolder    => ":$srcfolder",
            dosnapshot   => 0,
        };
        push( @queue, $bkpjob );

        $remotesubfolder =~ s|^/||g;
        print $fhExcludeFile "- $remotesubfolder/\n" unless $serverconfig{dryrun};
        print "- $remotesubfolder/\n" if $serverconfig{verbose};
    }
    close $fhExcludeFile unless $serverconfig{dryrun};

    # add bkp job for files only
    my $bkpjob = {
        jobid          => $jobid,
        host           => $host,
        group          => $group,
        path           => ":'${srcfolder}'",
        lastbkp        => $lastbkp,
        bkptimestamp   => $bkptimestamp,
        srcfolder      => ":$srcfolder",
        dosnapshot     => 0,
        exclsubfolders => 1,
    };
    push( @queue, $bkpjob );

    $bkpjob = {
        jobid        => $jobid,
        host         => $host,
        group        => $group,
        lastbkp      => $lastbkp,
        bkptimestamp => $bkptimestamp,
        dosnapshot   => $dosnapshot,
    };
    push( @finally_snapshots, $bkpjob );

    return 1;
}

#################################
# Threading
#
sub start_threads {

    # define number of threads
    my $nthreads;
    if ($nthreads_arg) {

        # If nthreads was defined by cli argument, use it
        $nthreads = $nthreads_arg;
        print "Using nthreads = $nthreads from command line argument\n" if $serverconfig{verbose};
    } elsif ( $host_arg && $group_arg ) {

        # If no nthreads was given, and we back up a single host and group, get nthreads from its config
        $nthreads = $hosts{"$host_arg-$group_arg"}->{hostconfig}->{BKP_THREADS_DEFAULT};
        print "Using nthreads = $nthreads from $host_arg-$group_arg config file\n" if $serverconfig{verbose};
    } else {
        $nthreads = 1;
    }

    my $Q = Thread::Queue->new;
    my @threads = map { threads->create( \&thread_work, $Q ) } ( 1 .. $nthreads );
    $Q->enqueue($_) for @queue;
    $Q->enqueue( (undef) x $nthreads );
    $_->join for @threads;

    return 1;
}

sub thread_work {
    my ($Q) = @_;

    while ( my $bkpjob = $Q->dequeue ) {
        my $tid            = threads->tid;
        my $jobid          = $bkpjob->{jobid};
        my $host           = $bkpjob->{host};
        my $group          = $bkpjob->{group};
        my $path           = $bkpjob->{path};
        my $lastbkp        = $bkpjob->{lastbkp};
        my $bkptimestamp   = $bkpjob->{bkptimestamp};
        my $srcfolder      = $bkpjob->{srcfolder};
        my $dosnapshot     = $bkpjob->{'dosnapshot'};
        my $exclsubfolders = $bkpjob->{'exclsubfolders'} || 0;

        my $random_integer = int( rand(10) ) + 1;
        $random_integer = 0 if ( $dryrun_arg || not $hosts{"$host-$group"}->{hostconfig}->{BKP_THREAD_SUBFOLDERS} );

        return unless create_lockfile( $taskid, $host, $group, $path );
        logit( $taskid, $host, $group, "Thread $tid sleep $random_integer sec. for $host-$group ($path)" );
        sleep($random_integer);
        logit( $taskid, $host, $group, "Thread $tid working on $host-$group ($path)" );
        my $rsync_err;
        $rsync_err = execute_rsync( $jobid, $host, $group, $lastbkp, $bkptimestamp, $path, $srcfolder ,$exclsubfolders );
        logit( $taskid, $host, $group, "Thread $tid finished with $host-$group ($path) ErrCode: $rsync_err" );
        unless (( $hosts{"$host-$group"}->{hostconfig}->{BKP_THREAD_SRCFOLDERS} && !$dosnapshot ) ||
                ( $hosts{"$host-$group"}->{hostconfig}->{BKP_THREAD_SUBFOLDERS} ) ||
                ( $finallysnapshots )) {
            my $bkpjob = {
                jobid        => $jobid,
                host         => $host,
                group        => $group,
                lastbkp      => $lastbkp,
                bkptimestamp => $bkptimestamp,
                rsync_err    => $rsync_err,
                dosnapshot   => $dosnapshot,
            };
            finish_backupjob($bkpjob);
        }
        remove_lockfile( $taskid, $host, $group, $path );
    }

    return 1;
}

#################################
# Rsync
#
sub eval_rsync_options {
    my ( $host, $group, $lastbkp ) = @_;
    my $rsync_options = '';
    my $hostconfig    = $hosts{"$host-$group"}->{hostconfig};

    $rsync_options .= '--stats ';
    $rsync_options .= '-a '            if $hostconfig->{BKP_RSYNC_ARCHIV};
    $rsync_options .= '-x '            if $hostconfig->{BKP_RSYNC_ONE_FS};
    $rsync_options .= '-R '            if $hostconfig->{BKP_RSYNC_RELATIV};
    $rsync_options .= '-H '            if $hostconfig->{BKP_RSYNC_HLINKS};
    $rsync_options .= '-W '            if $hostconfig->{BKP_RSYNC_WHOLEFILE};
    $rsync_options .= '-z '            if $hostconfig->{BKP_RSYNC_COMPRESS};
    $rsync_options .= '--delete '      if $hostconfig->{BKP_RSYNC_DELETE};
    $rsync_options .= '--force '       if $hostconfig->{BKP_RSYNC_DELETE_FORCE};
    $rsync_options .= '--numeric-ids ' if $hostconfig->{BKP_RSYNC_NUM_IDS};
    $rsync_options .= '--inplace '     if $hostconfig->{BKP_RSYNC_INPLACE};
    $rsync_options .= '--acls '        if $hostconfig->{BKP_RSYNC_ACL};
    $rsync_options .= '--xattrs '      if $hostconfig->{BKP_RSYNC_XATTRS};
    $rsync_options .= '--no-D '        if $hostconfig->{BKP_RSYNC_NODEVICES};
    $rsync_options .= '-v '            if ( $serverconfig{verbose} && ( $serverconfig{verboselevel} == 3 ) );
    $rsync_options .= "-M '$hostconfig->{BKP_RSYNC_REMOTE_OPT}' "          if $hostconfig->{BKP_RSYNC_REMOTE_OPT};
    $rsync_options .= "--rsync-path=$hostconfig->{BKP_RSYNC_RSHELL_PATH} " if $hostconfig->{BKP_RSYNC_RSHELL_PATH};

    if ( $hostconfig->{BKP_EXCLUDE_FILE} ) {
        my $excludefile = "$serverconfig{path_excludes}/$hostconfig->{BKP_EXCLUDE_FILE}";
        if ( -e $excludefile ) {
            $rsync_options .= "--exclude-from=$serverconfig{path_excludes}/$hostconfig->{BKP_EXCLUDE_FILE} ";
        } else {
            logit( $taskid, $host, $group, "Warning: could not find excludefile $excludefile." );
        }
    }

    # use links if told to
    if ( $hostconfig->{BKP_STORE_MODUS} eq 'links' ) {
        $rsync_options .= '--link-dest ' . targetpath( $host, $group ) . "/current ";
    }

    if ( $hostconfig->{BKP_RSYNC_RSHELL} ) {
        if ( $hostconfig->{BKP_GWHOST} ) {
            $rsync_options .= "-e '$hostconfig->{BKP_RSYNC_RSHELL} $hostconfig->{BKP_GWHOST}' 'rsh $host'";
        } else {
            $rsync_options .= "-e $hostconfig->{BKP_RSYNC_RSHELL} $host";
        }
    }

    $rsync_options =~ s/\s+$//;    # remove trailing space

    return $rsync_options;
}

sub check_rsync_target {
    my ( $host, $group ) = @_;
    my $return_code = 0;

    my $rsync_target = targetpath( $host, $group );

    if ( $hosts{"$host-$group"}->{hostconfig}->{BKP_STORE_MODUS} eq 'snapshots' ) {
        $rsync_target .= '/current';
    }

    if ( !-d $rsync_target ) {
        $return_code = 1;
    }

    return $return_code;
}

sub eval_rsync_target {
    my ( $host, $group, $bkptimestamp ) = @_;

    my $rsync_target = targetpath( $host, $group );

    if ( !-d $rsync_target ) {
        system("mkdir -p $rsync_target") unless $serverconfig{dryrun};
    }

    if ( $hosts{"$host-$group"}->{hostconfig}->{BKP_STORE_MODUS} eq 'snapshots' ) {
        $rsync_target .= '/current';

        if ( !-d $rsync_target ) {
            create_btrfs_subvolume( $host, $group, $rsync_target );
        }
    } else {
        $rsync_target .= "/$bkptimestamp";
    }

    return $rsync_target;
}

sub eval_rsync_generic_exclude_cmd {
    my ( $host, $group, $jobid ) = @_;
    my $exclsubfolderfilename = "generated.${host}_${group}_${jobid}";
    my $exclsubfolderopt      = "--exclude-from=$serverconfig{path_excludes}/$exclsubfolderfilename";

    return $exclsubfolderopt;
}

sub execute_rsync {
    my ( $jobid, $host, $group, $lastbkp, $bkptimestamp, $path, $srcfolder, $exclsubfolders ) = @_;

    $bkptimestamp = eval_bkptimestamp( $host, $group ) unless $bkptimestamp;
    my $startstamp = time();

    # append custom string to path written to DB if we are excluding subfolders
    my $bkpfrompath = $exclsubfolders ? "$path/FILESONLY" : $path;
    $bkpfrompath =~ s/'//g;
    $bkpfrompath =~ s/\/\//\//g;

    # report rsync start to DB, jobstatus => 0
    bangstat_start_backupjob( $taskid, $jobid, $host, $group, $startstamp, '', $bkpfrompath, $srcfolder, targetpath( $host, $group ), $lastbkp, '0', '0', '' ) unless $noreport;

    my $taskset = '';
    if ( $hosts{"$host-$group"}->{hostconfig}->{TASKSET_OPTIONS} ) {
        if ( -e $serverconfig{path_taskset} ) {
            $taskset = $serverconfig{path_taskset} . ' ' . $hosts{"$host-$group"}->{hostconfig}->{TASKSET_OPTIONS} . ' ';
        } else {
            logit( $taskid, $host, $group, "TASKSET selected but command $serverconfig{path_taskset} not found!" );
        }
    }

    my $nocache = '';
    if ( $hosts{"$host-$group"}->{hostconfig}->{NOCACHE_ENABLED} ) {
        if ( -e $serverconfig{path_nocache} ) {
            $nocache = $serverconfig{path_nocache} . ' ';
        } else {
            logit( $taskid, $host, $group, "NOCACHE selected but command $serverconfig{path_nocache} not found!" );
        }
    }

    my $ionice = '';
    if ( $hosts{"$host-$group"}->{hostconfig}->{IONICE_OPTIONS} ) {
        if ( -e $serverconfig{path_ionice} ) {
            $ionice = $serverconfig{path_ionice} . ' ' . $hosts{"$host-$group"}->{hostconfig}->{IONICE_OPTIONS} . ' ';
        } else {
            logit( $taskid, $host, $group, "IONICE selected but command $serverconfig{path_ionice} not found!" );
        }
    }

    my $rsync_cmd     = $nocache . $ionice . $taskset . $serverconfig{path_rsync};
    my $rsync_options = eval_rsync_options( $host, $group, $lastbkp );
    my $rsync_target  = eval_rsync_target( $host, $group, $bkptimestamp );

    my $rsync_generic_exclude = '';
    if ( $hosts{"$host-$group"}->{hostconfig}->{BKP_THREAD_SUBFOLDERS} && $exclsubfolders ) {
        $rsync_generic_exclude = eval_rsync_generic_exclude_cmd( $host, $group, $jobid );
        logit( $taskid, $host, $group, "Apply subfolder excludelist: $rsync_generic_exclude" );
    }

    logit( $taskid, $host, $group, "Rsync Command: $rsync_cmd $rsync_options$path $rsync_target" );
    logit( $taskid, $host, $group, "Executing rsync for host $host group $group path $path" );

    local ( *HIS_IN, *HIS_OUT, *HIS_ERR );
    $rsync_cmd = "echo $rsync_cmd" if $serverconfig{dryrun};
    my $rsyncpid = open3( *HIS_IN, *HIS_OUT, *HIS_ERR, "$rsync_cmd $rsync_generic_exclude $rsync_options$path $rsync_target" );

    logit( $taskid, $host, $group, "Rsync PID: $rsyncpid for host $host group $group path $path" );

    my @outlines = <HIS_OUT>;
    my @errlines = <HIS_ERR>;
    close HIS_IN;
    close HIS_OUT;
    close HIS_ERR;

    waitpid( $rsyncpid, 0 );

    logit( $taskid, $host, $group, "Rsync[$rsyncpid] STDOUT: @outlines" ) if ( @outlines && $serverconfig{verboselevel} >= 2 );
    logit( $taskid, $host, $group, "ERROR: Rsync[$rsyncpid] STDERR: @errlines" ) if @errlines;
    logit( $taskid, $host, $group, "ERROR: Rsync[$rsyncpid] child exited with status of $?" ) if $?;

    my $errcode  = 0;
    my $endstamp = time();

    if (@errlines) {
        foreach my $errline (@errlines) {
            if ( $errline =~ /.* \(code (\d+)/ ) {
                $errcode = $1;
                logit( $taskid, $host, $group, "Rsync errorcode: $errcode" );
            }
        }
    } else {
        logit( $taskid, $host, $group, "Rsync successful for host $host group $group path $path" );
    }

    #report finished rsync to DB, jobstatus => 1
    bangstat_update_backupjob( $taskid, $jobid, $host, $group, $endstamp, $bkpfrompath, targetpath( $host, $group ), $lastbkp, $errcode, '1', @outlines ) unless $noreport;

    return $errcode;
}

#################################
# Btrfs
#
sub create_btrfs_subvolume {
    my ( $host, $group, $path ) = @_;

    if ( -x $serverconfig{path_btrfs} ) {
        my $btrfs_subvolume_cmd = "$serverconfig{path_btrfs} subvolume create $path >/dev/null 2>&1";
        $btrfs_subvolume_cmd = "echo $btrfs_subvolume_cmd" if $serverconfig{dryrun};

        logit( $taskid, $host, $group, "Create btrfs subvolume: $btrfs_subvolume_cmd" );
        system($btrfs_subvolume_cmd) and logit( $taskid, $host, $group, "ERROR: creating subvolume for $host-$group: $!" );

    } else {
        logit( $taskid, $host, $group, "ERROR: could not create subvolumes, btrfs command not found, check path" );
    }
    return 1;
}

sub delete_btrfs_subvolume {
    my ( $host, $group, $path ) = @_;

    if ( -x $serverconfig{path_btrfs} ) {
        my $btrfs_subvolume_cmd = "$serverconfig{path_btrfs} subvolume delete $path >/dev/null 2>&1";
        $btrfs_subvolume_cmd = "echo $btrfs_subvolume_cmd" if $serverconfig{dryrun};

        logit( $taskid, $host, $group, "Delete btrfs subvolume: $btrfs_subvolume_cmd" );
        system($btrfs_subvolume_cmd) and logit( $taskid, $host, $group, "ERROR: deleting subvolume for $host-$group: $!" );

    } else {
        logit( $taskid, $host, $group, "ERROR: could not delete subfolders, btrfs command not found, check path" );
    }

    return 1;
}

sub create_btrfs_snapshot {
    my ( $host, $group, $bkptimestamp ) = @_;

    if ( -x $serverconfig{path_btrfs} ) {
        my $btrfs_cmd             = $serverconfig{path_btrfs};
        my $btrfs_snapshot_source = targetpath( $host, $group ) . '/current';
        my $btrfs_snapshot_dest   = targetpath( $host, $group ) . '/' . $bkptimestamp;

        my $touch_current_cmd = "touch $btrfs_snapshot_source >/dev/null 2>&1";
        $touch_current_cmd = "echo $touch_current_cmd" if $serverconfig{dryrun};
        logit( $taskid, $host, $group, "Touch current folder for host $host group $group" );
        system($touch_current_cmd) and logit( $taskid, $host, $group, "ERROR: touching current folder for $host-$group: $!" );

        my $btrfs_snapshot_cmd = "$btrfs_cmd subvolume snapshot -r $btrfs_snapshot_source $btrfs_snapshot_dest >/dev/null 2>&1";
        $btrfs_snapshot_cmd = "echo $btrfs_snapshot_cmd" if $serverconfig{dryrun};
        logit( $taskid, $host, $group, "Create btrfs snapshot for host $host group $group using $btrfs_snapshot_cmd" );
        system($btrfs_snapshot_cmd) and logit( $taskid, $host, $group, "ERROR: creating snapshot for $host-$group: $!" );

    } else {
        logit( $taskid, $host, $group, "ERROR: could not create snapshot, btrfs command not found, check path" );
    }

    return 1;
}

#################################
# Links
#
sub create_link_current {
    my ( $host, $group, $bkptimestamp ) = @_;

    my $link_source  = targetpath( $host, $group ) . '/' . $bkptimestamp;
    my $link_dest    = targetpath( $host, $group ) . '/current';
    my $ln_cmd       = "/bin/ln -s";

    if (-d $link_dest ){
        unlink $link_dest unless $serverconfig{dryrun};;
        logit( $taskid, $host, $group, "Delete existing current symlink for host $host group $group" );
    }

    my $link_cmd = "$ln_cmd $link_source $link_dest >/dev/null 2>&1";
    $link_cmd = "echo $link_cmd" if $serverconfig{dryrun};
    logit( $taskid, $host, $group, "Create symlink for host $host group $group using $link_cmd" );
    system($link_cmd) and logit( $taskid, $host, $group, "ERROR: creating symlink for $host-$group: $!" );

    return 1;
}

#################################
# Wipe old backups
#
sub wipe {
    my ( $host, $group, $force ) = @_;

    # make sure we are on the correct backup server
    return unless bkp_to_current_server( $host, $group );

    # make sure wipe is enabled
    return unless $hosts{"$host-$group"}->{hostconfig}->{WIPE_ENABLED};

    # stop if trying to do bulk wipe if it's not allowed
    return unless ( ( $group_arg && $host_arg ) || $hosts{"$host-$group"}->{hostconfig}->{WIPE_BULK_ALLOW} );

    # check for still running backups
    return unless check_lockfile( $taskid, $host, $group );

    logit( $taskid, $host, $group, "Wipe host $host group $group" );

    my @backup_folders = get_backup_folders( $host, $group );

    # count existing backups
    my $bkpkeep = 0;
    foreach my $type (qw( DAILY WEEKLY MONTHLY )) {
        $bkpkeep += $hosts{"$host-$group"}->{hostconfig}->{"WIPE_KEEP_$type"};
    }
    my $bkpcount = $#backup_folders + 1;

    # get list of folders to wipe
    my %stack = list_folders_to_wipe( $host, $group, @backup_folders );
    my @wipedirs = @{$stack{wipe}};

    logit( $taskid, $host, $group, "Wipe existing: $bkpcount, to wipe: " . ( $#{$stack{wipe}} + 1 ) . ", keeping: $bkpkeep for host $host group $group" );

    # generate wipe report with content of stacks
    if ( $serverconfig{verboselevel} >= 2 ) {
        my $wipe_report = "Wipe report\n";
        foreach my $type ( sort keys %stack ) {
            $wipe_report .= "\t" . uc($type) . " : " . ( $#{$stack{$type}} + 1 ) . "\n";
            foreach my $folder ( @{$stack{$type}} ) {
                $wipe_report .= "\t$folder\n";
            }
        }
        logit( $taskid, $host, $group, $wipe_report );
    }

    # don't automatically wipe too many backups
    if ($force) {
        logit( $taskid, $host, $group, 'Wipe WARNING: forced to wipe, namely ' . ( $#{$stack{wipe}} + 1 ) . '.' );
    } elsif ( $#{$stack{wipe}} >= $serverconfig{auto_wipe_limit} ) {
        logit( $taskid, $host, $group, 'Wipe WARNING: too many folders to wipe, namely ' . ( $#{$stack{wipe}} + 1 ) . '. Wipe manually or use --force.' );
        return ();
    }

    # make sure list contains at least one folder
    if ( !@wipedirs ) {
        logit( $taskid, $host, $group, "Wipe no folder to wipe for host $host group $group" );
        return 1;
    }

    # remove subvolumes or folders
    if ( $hosts{"$host-$group"}->{hostconfig}->{BKP_STORE_MODUS} eq 'snapshots' ) {

        # Limit snapshot wipe to the last x days -> performance issues
        if ( ( $#{$stack{wipe}} + 1 ) > $serverconfig{snapshot_wipe_limit} ) {
            logit( $taskid, $host, $group, "Wipe WARNING: snapshot limit reached, wipe only oldest $serverconfig{snapshot_wipe_limit} snapshots." );
        }
        @wipedirs = splice( @wipedirs, 0, $serverconfig{snapshot_wipe_limit} );

        delete_btrfs_subvolume( $host, $group, join( ' ', @wipedirs ) );
        delete_logfiles( $host, $group, @wipedirs );
    } else {
        my $rmcmd = 'rm -Rf';
        $rmcmd = "echo $rmcmd" if $serverconfig{dryrun};
        foreach my $dir (@wipedirs) {
            logit( $taskid, $host, $group, "Wipe $rmcmd $dir for host $host group $group" );
            system("$rmcmd $dir") and logit( $taskid, $host, $group, "ERROR: removing folder $dir for $host-$group: $!" );
        }
    }

    logit( $taskid, $host, $group, "Wipe successful of host $host group $group" );

    return 1;
}

sub delete_logfiles {
    my ( $host, $group, @wipedirs ) = @_;

    foreach my $dir (@wipedirs) {
        my ($logdate) = $dir =~ /.*\/(\d{4}\.\d{2}\.\d{2})/;
        $logdate =~ s/\./\-/g;
        my $today = `$serverconfig{path_date} +"%Y-%m-%d"`;
        chomp $today;
        unless ( $logdate eq $today ) {
            my $logfolder = "$serverconfig{path_logs}/${host}_${group}";
            my $logfile   = "$logfolder/$logdate.log";
            my $rmcmd     = 'rm -f';
            $rmcmd = "echo $rmcmd" if $serverconfig{dryrun};

            logit( $taskid, $host, $group, "Delete logfile $logfile" );
            system("$rmcmd $logfile") and logit( $taskid, $host, $group, "ERROR: deleting logfile $logfile: $!" );
        }
    }

    return 1;
}

#################################
# last_bkp_file
#
sub last_bkp_file {
    my ( $host, $group ) = @_;

    my $hostconfig  = $hosts{"$host-$group"}->{hostconfig};
    my $bkpdir      = "$hostconfig->{BKP_TARGET_PATH}/$hostconfig->{BKP_PREFIX}/$host";
    my $lastBkpFile = "$bkpdir/$hostconfig->{BKP_LASTBKP_FILE}";

    return $lastBkpFile;
}

sub check_last_bkp {
    my ( $host, $group ) = @_;

    my $lastbkp = 'nolastbkp';
    my $lastBkpFile = last_bkp_file( $host, $group );

    if ( -e $lastBkpFile ) {
        $lastbkp = `cat $lastBkpFile`;
        chomp($lastbkp);
    }

    logit( $taskid, $host, $group, "Found lastbkp = $lastbkp" );

    return $lastbkp;
}

sub create_last_bkp_file {
    my ( $host, $group, $bkptimestamp ) = @_;

    my $lastBkpFile = last_bkp_file( $host, $group );
    system("echo \"$bkptimestamp\" > $lastBkpFile") unless $serverconfig{dryrun};
    logit( $taskid, $host, $group, "Write lastBkpFile: $bkptimestamp \-\> $lastBkpFile" );

    return 1;
}

#################################
# Helper subroutines
#
sub create_timeid {
    my ( $host, $group ) = @_;

    my ( $s, $usec ) = gettimeofday;
    my $timeid = `$serverconfig{path_date} +"%Y%m%d%H%M%S"` . $usec;
    $timeid =~ s/\n//g;
    $host   ||= "SERVER";
    $group  ||= "GLOBAL";
    $taskid ||= $timeid;
    logit( $taskid, $host, $group, "Created TimeID: $timeid" );

    return $timeid;
}

sub eval_bkptimestamp {
    my ( $host, $group ) = @_;

    my $bkptimestamp = eval( $hosts{"$host-$group"}->{hostconfig}->{BKP_FOLDER} );
    chomp($bkptimestamp);

    return $bkptimestamp;
}

sub finish_backupjob {
    my ($bkpjob)     = @_;
    my $jobid        = $bkpjob->{'jobid'};
    my $host         = $bkpjob->{'host'};
    my $group        = $bkpjob->{'group'};
    my $bkptimestamp = $bkpjob->{'bkptimestamp'};
    my $lastbkp      = $bkpjob->{'lastbkp'};
    my $rsync_err    = $bkpjob->{'rsync_err'};
    my $dosnapshot   = $bkpjob->{'dosnapshot'};

    if ($dosnapshot) {
        if ( $hosts{"$host-$group"}->{hostconfig}->{BKP_STORE_MODUS} eq 'snapshots' ) {
            create_btrfs_snapshot( $host, $group, $bkptimestamp );
        }
        if ( $hosts{"$host-$group"}->{hostconfig}->{BKP_STORE_MODUS} eq 'links' ) {
            create_link_current( $host, $group, $bkptimestamp );
        }

        my %RecentBackups = bangstat_recentbackups($host);
        unless ($noreport) {
            xymon_report( $taskid, $host, $group, %RecentBackups );
            mail_report( $taskid, $host, $group, %RecentBackups ) if $serverconfig{report_to};
        }
        logit( $taskid, $host, $group, "Backup successful for host $host group $group!" );
    }

    # report finished job to DB, jobstatus => 2
    bangstat_finish_backupjob( $taskid, $jobid, $host, $group, '2' ) unless $noreport;

    remove_generic_exclude_file($host, $group, $jobid) if $hosts{"$host-$group"}->{hostconfig}->{BKP_THREAD_SUBFOLDERS};

    return 1;
}

sub bkp_to_current_server {
    my ( $host, $group ) = @_;

    # make sure backup's target host matches local hostname
    my $bkp_target_host = $hosts{"$host-$group"}->{hostconfig}->{BKP_TARGET_HOST};
    if ( $bkp_target_host ne $servername && $bkp_target_host ne '*' ) {
        logit( $taskid, $host, $group, "Skipping host $host group $group for server $bkp_target_host instead of $servername" ) if $serverconfig{verbose};
        return 0;
    }

    return 1;
}

sub generic_exclude_file {
    my ( $host, $group, $jobid ) = @_;
    my $exclsubfolderfilename = "generated.${host}_${group}_${jobid}";
    my $exclsubfolderfile     = "$serverconfig{path_excludes}/$exclsubfolderfilename";

    return $exclsubfolderfile;
}

sub create_generic_exclude_file {
    my ( $host, $group, $jobid ) = @_;
    my $exclsubfolderfile        = generic_exclude_file( $host, $group, $jobid );

    unless ( $serverconfig{dryrun} ) {
        system("touch \"$exclsubfolderfile\"") and logit( $taskid, $host, $group, "ERROR: could not create generated excludefile $exclsubfolderfile" );
    }
    logit( $taskid, $host, $group, "Create generated exclude file $exclsubfolderfile" );
    return $exclsubfolderfile;
}

sub remove_generic_exclude_file {
    my ( $host, $group, $jobid ) = @_;
    my $exclsubfolderfile        = generic_exclude_file( $host, $group, $jobid );

    if ( -e $exclsubfolderfile ) {
        unlink "$exclsubfolderfile";
    }
    logit( $taskid, $host, $group, "Remove generated exclude file $exclsubfolderfile" );

    return 1;
}

#################################
# Command line arguments
#
sub parse_command_options {

    GetOptions(
        'help'             => sub { usage('') },
        'version'          => sub { usage("Current version number: $version") },
        'v|verbose'        => \$verbose_arg,
        'vv'               => \$vv_arg,
        'vvv'              => \$vvv_arg,
        'n|dry-run'        => \$dryrun_arg,
        'g|group=s'        => \$group_arg,
        'h|host=s'         => \$host_arg,
        'p|prefix=s'       => \$prefix_arg,
        't|threads=i'      => \$nthreads_arg,
        'w|wipe'           => \$wipe,
        'initial'          => \$initial,
        'finallysnapshots' => \$finallysnapshots,
        'force'            => \$force,
        'missingonly'      => \$missingonly,
        'xymon'            => \$xymononly,
        'noreport'         => \$noreport,
    ) or usage('Invalid commmand line options.');
    usage('You must provide some arguments') unless ( $host_arg || $group_arg );
    usage('Number of threads must be positive') if ( $nthreads_arg && $nthreads_arg <= 0 );

    $verbose_arg = 1 if ( $dryrun_arg || $vv_arg || $vvv_arg );

    return 1;
}

sub cli_args_override_global_config {

    $serverconfig{verbose}      = $verbose_arg if $verbose_arg;
    $serverconfig{dryrun}       = $dryrun_arg  if $dryrun_arg;
    $serverconfig{verboselevel} = 2            if $vv_arg;
    $serverconfig{verboselevel} = 3            if $vvv_arg;

    return 1;
}

sub usage {
    my ($message) = @_;

    if ( defined $message && length $message ) {
        $message .= "\n"
            unless $message =~ /\n$/;
    }

    my $command = $0;
    $command =~ s#^.*/##;

    print <<"EOF";
        $message
        Usage Examples:

        $command -h <host> -g <group> # back up given host and group
        $command -h <host>            # back up all groups of given host
        $command -g <group>           # back up all hosts of given group
        $command --help               # show this help message
        $command --version            # show version number and help

        Optional Arguments:

        -t <nr>            # number of threads, default: 1
        -p <path>          # override path to folder containing etc/
        -w                 # wipe the backup
        -w --force         # forcing wipe the backup (override auto_wipe_limit)
        --initial          # create nonexisting backup targets
        --finallysnapshots # make snapshots after the hole backup stuff
        --missingonly      # backup only hosts that were not backed up recently
        --xymon            # send only xymon report
        --noreport         # do not send any report
        -v | -vv | -vvv    # verbose mode to include debugging messages of level 1-3
        -n                 # dry-run without making changes (implies verbose)

EOF

    exit 0;
}
