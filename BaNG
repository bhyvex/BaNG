#!/usr/bin/env perl
#
# Copyright 2013 Patrick Schmid <schmid@phys.ethz.ch>, distributed under
# the terms of the GNU General Public License version 2 or later.
#
# Authors: Patrick Schmid <schmid@phys.ethz.ch> & Claude Becker <becker@phys.ethz.ch>
#
use strict;
use warnings;
use Cwd 'abs_path';
use File::Basename;
use Getopt::Long qw(:config no_auto_abbrev);
use IPC::Open3;
use Mail::Sendmail;
use threads;
use Thread::Queue;

use lib dirname(abs_path($0))."/lib";
use BaNG::Hosts;
use BaNG::Config;
use BaNG::Reporting;
our %hosts;

my $version    = '3.0';
my $debug      = 1;
my $debuglevel = 2;
my $wipe;
my $group_arg;
my $host_arg;
my $nthreads_arg;
my $nthreads;
my @queue;

#################################
# Main
#
parse_command_options();
get_global_config();
get_host_config($host_arg, $group_arg);

foreach my $config (keys %hosts) {
    if ( $wipe ) {
        wipe( $hosts{$config}->{hostname}, $hosts{$config}->{group} );
    } else {
        queue_backup( $hosts{$config}->{hostname}, $hosts{$config}->{group} );
    }
}
print "Queue: @queue\n" if $debug;

if( !@queue ) {
    print "Exit because queue is empty.\n" if $debug;
    exit 0;
}

start_threads();

exit 0;

#################################
# Queuing
#
sub queue_backup {
    my ($host, $group) = @_;

    print "sub queue_backup($host, $group)\n" if $debug;

    # make sure backup is enabled
    return unless $hosts{"$host-$group"}->{status} eq 'enabled';
    # stop if trying to do bulk backup if it's not allowed
    return unless ( ($group_arg && $host_arg) || $hosts{"$host-$group"}->{hostconfig}->{BKP_BULK_ALLOW});

    # make sure host is online
    my ($conn_status, $conn_msg ) = chkClientConn($host, $hosts{"$host-$group"}->{hostconfig}->{BKP_GWHOST});
    print "chkClientConn: $conn_status, $conn_msg\n" if $debug;
    if( !$conn_status ) {
        print "Error: host $host is offline\n" if $debug;
        return 1;
    }

    # check if last backup exists
    my $lastbkp = chkLastBkp($host, $group);

    # get list of partitions to back up
    my (@src_part) = split ( / /, $hosts{"$host-$group"}->{hostconfig}->{BKP_SOURCE_PARTITION});
    print "Number of partitions: " . ($#src_part+1) . " ( @src_part )\n" if $debug;

    # optionally queue each subfolder of the partitions
    if( $hosts{"$host-$group"}->{hostconfig}->{BKP_THREAD_SUBFOLDERS} ) {
        foreach my $part (@src_part) {
            queue_remote_subfolders($host,$group, $lastbkp, $part);
        }
    } else {
        # queue list of partitions as a whole
        push @queue, "${host}__${group}__${lastbkp}__0__@src_part";
    }

    print "Queued backup of host $host group $group\n" if $debug;

    return 1;
}

sub queue_remote_subfolders {
    my ($host, $group, $lastbkp, $partition) = @_;

    $partition =~ s/://;

    my $remoteshell   = $hosts{"$host-$group"}->{hostconfig}->{BKP_RSYNC_RSHELL};
    my @remotedirlist = `$remoteshell $host find $partition -xdev -mindepth 1 -maxdepth 1`;
    print "eval subfolders command: @remotedirlist\n" if $debug;

    my $bkptimestamp = eval_bkptimestamp($host, $group);

    foreach my $remotedir (@remotedirlist) {
        chomp $remotedir;
        $remotedir =~ s| |\\ |g;
        push @queue, "${host}__${group}__${lastbkp}__${bkptimestamp}__:'${remotedir}'";
    }

    return 1;
}

#################################
# Threading
#
sub start_threads {

    # define number of threads
    if( $nthreads_arg ){
        # If nthreads was defined by cli argument, use it
        $nthreads = $nthreads_arg;
        print "Using nthreads = $nthreads from command line argument\n" if $debug;
    } elsif ( $host_arg && $group_arg) {
        # If no nthreads was given, and we back up a single host and group, get nthreads from its config
        $nthreads = $hosts{"$host_arg-$group_arg"}->{hostconfig}->{BKP_THREADS_DEFAULT};
        print "Using nthreads = $nthreads from $host_arg-$group_arg config file\n" if $debug;
    } else {
        $nthreads = 1;
    }

    my $Q = Thread::Queue->new;
    my @threads = map threads->create( \&thread_work, $Q ), 1 .. $nthreads;
    $Q->enqueue($_) for sort @queue;
    $Q->enqueue( (undef) x $nthreads );
    $_->join for @threads;

    return 1;
}

sub thread_work {
    my $Q   = shift;
    my $tid = threads->tid;
    while (my $queue_content = $Q->dequeue) {

        print "Thread $tid working on $queue_content \n" if $debug;

        my ($host, $group, $lastbkp, $bkptimestamp, $path) = split( /__/, $queue_content);

        return unless createLockFile($host, $group, $path);
        execute_rsync($host, $group, $lastbkp, $bkptimestamp, $path);
        removeLockFile($host, $group, $path);
    }

    return 1;
}

#################################
# Rsync
#
sub eval_rsync_options {
    my ($host, $group, $lastbkp) = @_;
    my $rsync_options  = '';
    my $hostconfig = $hosts{"$host-$group"}->{hostconfig};

    $rsync_options .= "--stats ";
    $rsync_options .= "-ax "            if $hostconfig->{BKP_RSYNC_ARCHIV};
    $rsync_options .= "-R "             if $hostconfig->{BKP_RSYNC_RELATIV};
    $rsync_options .= "-H "             if $hostconfig->{BKP_RSYNC_HLINKS};
    $rsync_options .= "--delete "       if $hostconfig->{BKP_RSYNC_DELETE};
    $rsync_options .= "--force "        if $hostconfig->{BKP_RSYNC_DELETE_FORCE};
    $rsync_options .= "--numeric-ids "  if $hostconfig->{BKP_RSYNC_NUM_IDS};
    $rsync_options .= "--inplace "      if $hostconfig->{BKP_RSYNC_INPLACE};
    $rsync_options .= "--acls "         if $hostconfig->{BKP_RSYNC_ACL};
    $rsync_options .= "--xattrs "       if $hostconfig->{BKP_RSYNC_XATTRS};
    $rsync_options .= "--no-D "         if $hostconfig->{BKP_RSYNC_OSX};
    $rsync_options .= "-v "             if ($debug && ($debuglevel == 3));
    $rsync_options .= "--rsync-path=$hostconfig->{BKP_RSYNC_RSHELL_PATH} " if $hostconfig->{BKP_RSYNC_RSHELL_PATH};

    if ($hostconfig->{BKP_EXCLUDE_FILE}) {
        my $excludefile = "$globalconfig{path_excludes}/$hostconfig->{BKP_EXCLUDE_FILE}";
        if ( -e $excludefile ) {
            $rsync_options .= "--exclude-from=$globalconfig{path_excludes}/$hostconfig->{BKP_EXCLUDE_FILE} ";
        } else {
            print "Warning: excludefile $excludefile not found.\n" if $debug;
        }
    }

    if ($hostconfig->{BKP_RSYNC_RSHELL}){
        if ($hostconfig->{BKP_GWHOST}){
            $rsync_options .= "-e $hostconfig->{BKP_RSYNC_RSHELL} $hostconfig->{BKP_GWHOST} ";
        } else {
            $rsync_options .= "-e $hostconfig->{BKP_RSYNC_RSHELL} ";
        }
    }

    # use links if told to and if lastbkp exists
    if ( ($hostconfig->{BKP_STORE_MODUS} eq 'links') && ($lastbkp ne 'nolastbkp') ) {
        $rsync_options .= "--link-dest " . targetpath($host, $group) . "/$lastbkp ";
    }

    $rsync_options =~ s/\s+$//; # remove trailing space

    return $rsync_options;
}

sub eval_rsync_target {
    my ($host, $group, $bkptimestamp) = @_;

    my $rsync_target = targetpath($host, $group);

    if ($hosts{"$host-$group"}->{hostconfig}->{BKP_STORE_MODUS} eq 'snapshots' ) {
        $rsync_target .= "/current";

        if ( !-d $rsync_target ) {
            print "$globalconfig{path_btrfs} subvol create $rsync_target\n" if $debug;
        }
    } else {
        if ( !-d $rsync_target ) {
            system("mkdir -p $rsync_target");
        }

        $rsync_target .= "/$bkptimestamp";
    }

    return $rsync_target;
}

sub execute_rsync {
    my ($host, $group, $lastbkp, $bkptimestamp, $path) = @_;

    $bkptimestamp  = eval_bkptimestamp($host, $group) unless $bkptimestamp;
    my $startstamp = `date +%s`;

    my $rsync_cmd     = $globalconfig{path_rsync};
    my $rsync_options = eval_rsync_options($host,$group, $lastbkp);
    my $rsync_source  = "$host$path";
    my $rsync_target  = eval_rsync_target($host, $group, $bkptimestamp);
    print "Rsync Command: $rsync_cmd $rsync_options $rsync_source $rsync_target\n" if $debug;

    print "Executing rsync for host $host group $group path $path\n" if $debug;

    local(*HIS_IN, *HIS_OUT, *HIS_ERR);
    #sleep(rand($nthreads));

    my $rsyncpid = open3(
       *HIS_IN,
       *HIS_OUT,
       *HIS_ERR,
       "$rsync_cmd $rsync_options $rsync_source $rsync_target"
    );
    my @outlines = <HIS_OUT>;
    my @errlines = <HIS_ERR>;
    close HIS_IN;
    close HIS_OUT;
    close HIS_ERR;

    print "Rsync STDOUT: @outlines\n" if ($debug && @outlines);
    print "Rsync STDERR: @errlines\n" if ($debug && @errlines);
    print "Rsync child exited with status of $?\n" if $?;

    my $errcode = 0;
    if ( @errlines ){
        foreach my $errline (@errlines) {
            chomp $errline;
            ($errcode) = $errline = /.* \(code (\d+)/;
            print "Rsync errorcode: $errcode\n" if $errcode;
        }
    }
    else{
        my $endstamp = `date +%s`;
        createLastBkpFile($host, $group, $bkptimestamp);
        db_report($host, $group, $startstamp, $endstamp, $path, targetpath($host, $group), $bkptimestamp, @outlines);
        print "Backup successful for host $host group $group path $path!\n" if $debug;
    }

    return 1;
}

#################################
# Wipe old backups
#
sub wipe {
    my ($host, $group) = @_;

    print "Wipe host $host group $group\n" if $debug;

    return 1;
}

#################################
# Lockfile
#
sub LockFile {
    my ($host, $group, $path) = @_;

    $path =~ s/^://g;
    $path =~ s/\s:/\+/g;
    $path =~ s/\//%/g;
    my $lockfilename = "${host}_${group}_${path}";
    my $lockfile = "$globalconfig{path_lockfiles}/$lockfilename";

    return $lockfile;
}

sub createLockFile {
    my ($host, $group, $path) = @_;

    my $lockfile = LockFile($host, $group, $path);

    if ( -e $lockfile ) {
        print "ERROR: lockfile $lockfile still exists\n";
        return 0;
    } else {
        system("touch \"$lockfile\"") and print "ERROR: could not create lockfile $lockfile\n";
        print "Created lockfile $lockfile.\n" if $debug;
        return 1;
    }
}

sub removeLockFile {
    my ($host, $group, $path) = @_;

    my $lockfile = LockFile($host, $group, $path);
    print "Removed lockfile $lockfile.\n" if $debug;
    unlink $lockfile;

    return 1;
}

#################################
# LastBkpFile
#
sub LastBkpFile {
    my ($host, $group) = @_;

    my $hostconfig  = $hosts{"$host-$group"}->{hostconfig};
    my $bkpdir      = "$hostconfig->{BKP_TARGET_PATH}/$hostconfig->{BKP_PREFIX}/$host";
    my $lastBkpFile = "$bkpdir/$hostconfig->{BKP_LASTBKP_FILE}";

    return $lastBkpFile;
}

sub chkLastBkp {
    my ($host, $group) = @_;

    my $lastbkp = 'nolastbkp';
    my $lastBkpFile = LastBkpFile($host, $group);

    if ( -e $lastBkpFile ){
        $lastbkp = `cat $lastBkpFile`;
        chomp($lastbkp);
    }

    print "sub chkLastBkp: lastbkp = $lastbkp\n" if $debug;

    return $lastbkp;
}

sub createLastBkpFile {
    my ($host, $group, $bkptimestamp) = @_;

    my $lastBkpFile = LastBkpFile($host, $group);
    system("echo \"$bkptimestamp\" > $lastBkpFile");

    return 1;
}

#################################
# Helper subroutines
#
sub eval_bkptimestamp {
    my ($host, $group) = @_;

    my $bkptimestamp = eval( $hosts{"$host-$group"}->{hostconfig}->{BKP_FOLDER} );
    chomp($bkptimestamp);

    return $bkptimestamp;
}

sub targetpath {
    my ($host, $group) = @_;

    my $hostconfig  = $hosts{"$host-$group"}->{hostconfig};
    my $target_path = "$hostconfig->{BKP_TARGET_PATH}/$hostconfig->{BKP_PREFIX}/$host";

    return $target_path;
}

#################################
# Reporting
#
sub db_report {
    my ($host, $group, $startstamp, $endstamp, $path, $targetpath ,$bkptimestamp, @outlines) = @_;

    my %parse_log_keys = (
        'last backup'                 => 'LastBkp',
        'Number of files'             => 'NumOfFiles',
        'Number of files transferred' => 'NumOfFilesTrans',
        'Total file size'             => 'TotFileSize',
        'Total transferred file size' => 'TotFileSizeTrans',
        'Literal data'                => 'LitData',
        'Matched data'                => 'MatchData',
        'File list size'              => 'FileListSize',
        'File list generation time'   => 'FileListGenTime',
        'File list transfer time'     => 'FileListTransTime',
        'Total bytes sent'            => 'TotBytesSent',
        'Total bytes received'        => 'TotBytesRcv',
    );

    my %log_values;
    foreach my $outline ( @outlines ) {
        next unless $outline =~ m/:/;
        chomp $outline;
        my ($key, $value) = split(': ', $outline);
        foreach my $logkey ( keys %parse_log_keys ) {
            if ( $logkey eq $key ) {
                $value =~ s/^\D*([\d.]+).*?$/$1/;
                $log_values{$parse_log_keys{$logkey}} = $value;
            }
        }
    }

    $path =~ s/'//g;    # rm quotes to avoid errors in sql syntax
    my $isSubfolderThread = $hosts{"$host-$group"}->{hostconfig}->{BKP_THREAD_SUBFOLDERS} ? 'true' : 'NULL';

    my $sql;
    $sql .= "INSERT INTO statistic (";
    $sql .= " BkpFromHost, BkpFromPath, BkpToHost, BkpToPath, LastBkp, isThread, Start, Stop, ";
    $sql .= " NumOfFiles, NumOfFilesTrans, TotFileSize, TotFileSizeTrans, LitData, MatchData, ";
    $sql .= " FileListSize, FileListGenTime, FileListTransTime, TotBytesSent, TotBytesRcv ";
    $sql .= ") VALUES (";
    $sql .= "'$host', '$path', 'phd-bkp-gw', '$targetpath', '$bkptimestamp', ";
    $sql .= " $isSubfolderThread , FROM_UNIXTIME('$startstamp'), FROM_UNIXTIME('$endstamp'), ";
    $sql .= "'$log_values{NumOfFiles}'  , '$log_values{NumOfFilesTrans}', ";
    $sql .= "'$log_values{TotFileSize}' , '$log_values{TotFileSizeTrans}', ";
    $sql .= "'$log_values{LitData}'     , '$log_values{MatchData}', ";
    $sql .= "'$log_values{FileListSize}', '$log_values{FileListGenTime}', '$log_values{FileListTransTime}', ";
    $sql .= "'$log_values{TotBytesSent}', '$log_values{TotBytesRcv}' ";
    $sql .= ")";

    bangstat_db_connect();
    my $sth = $BaNG::Reporting::bangstat_dbh->prepare($sql);
    $sth->execute();
    $sth->finish();
}

sub mail_report {
    my ( $host, $targetpath ) = @_;

    my %mail = (
        To      => 'schmid@phys.ethz.ch',
        From    => 'root@phys.ethz.ch',
        Subject => "Backup report of ($host): success",
        Message => "* * * Backup report * * *\n\nBacking up: $host:$targetpath\n\n* * * Backup successfull * * *\n",
    );
    sendmail(%mail) or print "mail_report error: $Mail::Sendmail::error";

    return 1;
}

#################################
# Command line arguments
#
sub parse_command_options {

    GetOptions (
        "help"         => sub { usage('') },
        "v|version"    => sub { usage("Current version number: $version") },
        "d|debug"      => \$debug,
        "g|group=s"    => \$group_arg,
        "h|host=s"     => \$host_arg,
        "t|threads=i"  => \$nthreads_arg,
        "w|wipe"       => \$wipe,
    )
    or usage("Invalid commmand line options.");
    usage("You must provide some arguments")    unless ( $host_arg || $group_arg );
    usage("Number of threads must be positive") if ( $nthreads_arg && $nthreads_arg <= 0 );
}

sub usage {
    my ($message) = @_;

    if (defined $message && length $message) {
        $message .= "\n"
            unless $message =~ /\n$/;
    }

    my $command = $0;
    $command    =~ s#^.*/##;

    print STDERR (
        $message, qq(
        Usage Examples:

        $command -h <hostname> -g <group>   # back up given host and group
        $command -h <hostname>              # back up all groups of given host
        $command -g <group>                 # back up all hosts of given group
        $command -v                         # show version number
        $command --help                     # show this help message

        Optional Arguments:

        -t <nr>         # number of threads, default: 1
        -w              # wipe the backup
        -d              # show debugging messages
    \n)
    );
    exit 0;
}
